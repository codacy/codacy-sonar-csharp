<?xml version="1.0" encoding="utf-8"?>
<rules>
  <rule>
    <key>S3442</key>
    <type>CODE_SMELL</type>
    <name>"abstract" classes should not have "public" constructors</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Since <code>abstract</code> classes can't be instantiated, there's no point in their having <code>public</code> or <code>internal</code>
constructors. If there is basic initialization logic that should run when an extending class instance is created, you can by all means put it in a
constructor, but make that constructor <code>private</code> or <code>protected</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
abstract class Base
{
    public Base() // Noncompliant, should be private or protected
    {
      //...
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
abstract class Base
{
    protected Base()
    {
      //...
    }
}
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3244</key>
    <type>BUG</type>
    <name>Anonymous delegates should not be used to unsubscribe from Events</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That's because the
process of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove <em>this item</em> from the subscription
list. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added.
The result: <code>NOOP</code>.</p>
<p>Instead, save the delegate to a variable and use the variable to subscribe and unsubscribe.</p>
<h2>Noncompliant Code Example</h2>
<pre>
listView.PreviewTextInput += (obj,args) =&gt;
        listView_PreviewTextInput(obj,args,listView);

// ...

listView.PreviewTextInput -= (obj, args) =&gt;
        listView_PreviewTextInput(obj, args, listView); // Noncompliant; this delegate was never subscribed
</pre>
<h2>Compliant Solution</h2>
<pre>
EventHandler func = (obj,args) =&gt; listView_PreviewTextInput(obj,args,listView);

listView.PreviewTextInput += func;

// ...

listView.PreviewTextInput -= func;
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3236</key>
    <type>CODE_SMELL</type>
    <name>Caller information arguments should not be provided explicitly</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Caller information attributes: <code>CallerFilePathAttribute</code> and <code>CallerLineNumberAttribute</code> provide a way to get information
about the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not
explicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void TraceMessage(string message,
  [CallerFilePath] string filePath = null,
  [CallerLineNumber] int lineNumber = 0)
{
  /* ... */
}

void MyMethod()
{
  TraceMessage("my message", "A.B.C.Foo.cs", 42); // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void TraceMessage(string message,
  [CallerFilePath] string filePath = "",
  [CallerLineNumber] int lineNumber = 0)
{
  /* ... */
}

void MyMethod()
{
  TraceMessage("my message");
}
</pre>
<h2>Exceptions</h2>
<p><code>CallerMemberName</code> is not checked to avoid False-Positives with WPF/UWP applications.</p>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2330</key>
    <type>CODE_SMELL</type>
    <name>Array covariance should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Array covariance is the principle that if an implicit or explicit reference conversion exits from type <code>A</code> to <code>B</code>, then the
same conversion exists from the array type <code>A[]</code> to <code>B[]</code>.</p>
<p>While this array conversion can be useful in readonly situations to pass instances of <code>A[]</code> where <code>B[]</code> is expected, it must
be used with care, since assigning an instance of <code>B</code> into an array of <code>A</code> will cause an <code>ArrayTypeMismatchException</code>
to be thrown at runtime.</p>
<h2>Noncompliant Code Example</h2>
<pre>
abstract class Fruit { }
class Apple : Fruit { }
class Orange : Fruit { }

class Program
{
  static void Main(string[] args)
  {
    Fruit[] fruits = new Apple[1]; // Noncompliant - array covariance is used
    FillWithOranges(fruits);
  }

  // Just looking at the code doesn't reveal anything suspicious
  static void FillWithOranges(Fruit[] fruits)
  {
    for (int i = 0; i &lt; fruits.Length; i++)
    {
      fruits[i] = new Orange(); // Will throw an ArrayTypeMismatchException
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
abstract class Fruit { }
class Apple : Fruit { }
class Orange : Fruit { }

class Program
{
  static void Main(string[] args)
  {
    Orange[] fruits = new Orange[1]; // Compliant
    FillWithOranges(fruits);
  }

  static void FillWithOranges(Orange[] fruits)
  {
    for (int i = 0; i &lt; fruits.Length; i++)
    {
      fruits[i] = new Orange();
    }
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1121</key>
    <type>CODE_SMELL</type>
    <name>Assignments should not be made from within sub-expressions</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have
side-effects.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (string.IsNullOrEmpty(result = str.Substring(index, length))) // Noncompliant
{
  //...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
var result = str.Substring(index, length);
if (string.IsNullOrEmpty(result))
{
  //...
}
</pre>
<h2>Exceptions</h2>
<p>Assignments inside lambda and delegate expressions are allowed. </p>
<p>Furthermore, the following patterns are also accepted:</p>
<pre>
var a = b = c = 10;
</pre>
<pre>
while ((val = GetNewValue()) &gt; 0)
{
...
}
</pre>
<pre>
private MyClass instance;
public MyClass Instance
{
  get
  {
    return instance ?? (instance = new MyClass());
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value </li>
  <li> MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions </li>
  <li> MISRA C:2012, 13.4 - The result of an assignment operator should not be used </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/481.html">MITRE, CWE-481</a> - Assigning instead of Comparing </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/nYFtAg">CERT, EXP45-C.</a> - Do not perform assignments in selection statements </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/1gCTAw">CERT, EXP51-J.</a> - Do not perform assignments in conditional expressions
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/KQvhAg">CERT, EXP19-CPP.</a> - Do not perform assignments in conditional expressions
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/KYIyAQ">CERT, MSC02-CPP.</a> - Avoid errors of omission </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2306</key>
    <type>CODE_SMELL</type>
    <name>"async" and "await" should not be used as identifiers</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Since C# 5.0, <code>async</code> and <code>await</code> are contextual keywords. Contextual keywords do have a particular meaning in some contexts,
but can still be used as variable names. Keywords, on the other hand, are always reserved, and therefore are not valid variable names. To avoid any
confusion though, it is best to not use <code>async</code> and <code>await</code> as identifiers.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int await = 42; // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
int someOtherName = 42;
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3168</key>
    <type>BUG</type>
    <name>"async" methods should not return "void"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>An <code>async</code> method with a <code>void</code> return type is a "fire and forget" method best reserved for event handlers because there's no
way to wait for the method's execution to complete and respond accordingly. There's also no way to <code>catch</code> exceptions thrown from the
method.</p>
<p>Having an <code>async void</code> method that is not an event handler could mean your program works some times and not others because of timing
issues. Instead, <code>async</code> methods should return <code>Task</code>.</p>
<p>This rule raises an issue when non-event handler methods are both <code>async</code> and <code>void</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class HttpPrinter
{
  private string content;

  public async void CallNetwork(string url) //Noncompliant
  {
    var client = new HttpClient();
    var response = await client.GetAsync(url);
    content = await response.Content.ReadAsStringAsync();
  }

  public async Task PrintContent(string url)  // works correctly if web request finishes in under 1 second, otherwise content will be null
  {
    CallNetwork(url);
    await Task.Delay(1000);
    Console.Write(content);
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class HttpPrinter
{
  private string content;

  public async Task CallNetwork(string url)
  {
    var client = new HttpClient();
    var response = await client.GetAsync(url);
    content = await response.Content.ReadAsStringAsync();
  }

  public async Task PrintContent(string url)
  {
    await CallNetwork(url); // &lt;----- call changed here. If await is not added warning CS4014 will be triggered
    await Task.Delay(1000);
    Console.Write(content);
  }
}
</pre>

]]></description>
    <tag>multi-threading</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S110</key>
    <type>CODE_SMELL</type>
    <name>Inheritance tree of classes should not be too deep</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Inheritance is certainly one of the most valuable concepts in object-oriented programming. It's a way to compartmentalize and reuse code by
creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating
a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object
oriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better.</p>
<p>This rule raises an issue when the inheritance tree, starting from <code>Object</code> has a greater depth than is allowed. </p>

]]></description>
    <tag>design</tag>
    <param>
      <key>max</key>
      <description><![CDATA[Maximum depth of the inheritance tree. (Number)]]></description>
      <type>INTEGER</type>
      <defaultValue>5</defaultValue>
    </param>
    <param>
      <key>filteredClasses</key>
      <description><![CDATA[Classes to be filtered out of the count of inheritance. Depth counting will stop when a filtered class is reached. (String)]]></description>
      <type>STRING</type>
      <defaultValue />
    </param>
    <remediationFunctionBaseEffort />
  </rule>
  <rule>
    <key>S1764</key>
    <type>BUG</type>
    <name>Identical expressions should not be used on both sides of a binary operator</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste
error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical
operators, having the same value on both sides of an operator yields predictable results, and should be simplified.</p>
<p>This rule ignores <code>*</code>, <code>+</code>, <code>=</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if ( a == a ) // always true
{
  doZ();
}
if ( a != a ) // always false
{
  doY();
}
if ( a == b &amp;&amp; a == b ) // if the first one is true, the second one is too
{
  doX();
}
if ( a == b || a == b ) // if the first one is true, the second one is too
{
  doW();
}

int j = 5 / 5; //always 1
int k = 5 - 5; // always 0

c.Equals(c);    //always true
Object.Equals(c, c); //always true
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
  <li> {rule:csharpsquid:S1656} - Implements a check on <code>=</code>. </li>
</ul>

]]></description>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1940</key>
    <type>CODE_SMELL</type>
    <name>Boolean checks should not be inverted</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if ( !(a == 2)) { ...}  // Noncompliant
bool b = !(i &lt; 10);  // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
if (a != 2) { ...}
bool b = (i &gt;= 10);
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1125</key>
    <type>CODE_SMELL</type>
    <name>Boolean literals should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Redundant Boolean literals should be removed from expressions to improve readability.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (booleanMethod() == true) { /* ... */ }
if (booleanMethod() == false) { /* ... */ }
if (booleanMethod() || false) { /* ... */ }
doSomething(!false);
doSomething(booleanMethod() == true);

booleanVariable = booleanMethod() ? true : false;
booleanVariable = booleanMethod() ? true : exp;
booleanVariable = booleanMethod() ? false : exp;
booleanVariable = booleanMethod() ? exp : true;
booleanVariable = booleanMethod() ? exp : false;

for (var x = 0; true; x++)
{
 ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (booleanMethod()) { /* ... */ }
if (!booleanMethod()) { /* ... */ }
if (booleanMethod()) { /* ... */ }
doSomething(true);
doSomething(booleanMethod());

booleanVariable = booleanMethod();
booleanVariable = booleanMethod() || exp;
booleanVariable = !booleanMethod() &amp;&amp; exp;
booleanVariable = !booleanMethod() || exp;
booleanVariable = booleanMethod() &amp;&amp; exp;

for (var x = 0; ; x++)
{
 ...
}
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1227</key>
    <type>CODE_SMELL</type>
    <name>break statements should not be used except for switch cases</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>break;</code> is an unstructured control flow statement which makes code harder to read.</p>
<p>Ideally, every loop should have a single termination condition.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int i = 0;
while (true)
{
  if (i == 10)
  {
    break;      // Non-Compliant
  }

  Console.WriteLine(i);
  i++;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int i = 0;
while (i != 10) // Compliant
{
  Console.WriteLine(i);
  i++;
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3215</key>
    <type>CODE_SMELL</type>
    <name>"interface" instances should not be cast to concrete types</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Needing to cast from an <code>interface</code> to a concrete type indicates that something is wrong with the abstractions in use, likely that
something is missing from the <code>interface</code>. Instead of casting to a discrete type, the missing functionality should be added to the
<code>interface</code>. Otherwise there is a risk of runtime exceptions.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public interface IMyInterface
{
  void DoStuff();
}

public class MyClass1 : IMyInterface
{
  public int Data { get { return new Random().Next(); } }

  public void DoStuff()
  {
    // TODO...
  }
}

public static class DowncastExampleProgram
{
  static void EntryPoint(IMyInterface interfaceRef)
  {
    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant
    int privateData = class1.Data;

    class1 = interfaceRef as MyClass1;  // Noncompliant
    if (class1 != null)
    {
      // ...
    }
  }
}
</pre>
<h2>Exceptions</h2>
<p>Casting to <code>object</code> doesn't raise an issue, because it can never fail.</p>
<pre>
static void EntryPoint(IMyInterface interfaceRef)
{
  var o = (object)interfaceRef;
  ...
}
</pre>

]]></description>
    <tag>design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1h</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3247</key>
    <type>CODE_SMELL</type>
    <name>Duplicate casts should not be made</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Because the <code>is</code> operator performs a cast if the object is not null, using <code>is</code> to check type and then casting the same
argument to that type, necessarily performs two casts. The same result can be achieved more efficiently with a single cast using <code>as</code>,
followed by a null-check.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (x is Fruit)  // Noncompliant
{
  var f = (Fruit)x; // or x as Fruit
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
var f = x as Fruit;
if (f != null)
{
  // code
}
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2486</key>
    <type>CODE_SMELL</type>
    <name>Generic exceptions should not be ignored</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.</p>
<p>This rule only reports on empty catch clauses that catch generic <code>Exception</code>s.</p>
<h2>Noncompliant Code Example</h2>
<pre>
string text = "";
try
{
  text = File.ReadAllText(fileName);
}
catch (Exception exc) // Noncompliant
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
string text = "";
try
{
  text = File.ReadAllText(fileName);
}
catch (Exception exc)
{
  logger.Log(exc);
}
</pre>
<h2>Exceptions</h2>
<p>When a block contains a comment, it is not considered to be empty.</p>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/391.html">MITRE, CWE-391</a> - Unchecked Error Condition </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>error-handling</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1h</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2737</key>
    <type>CODE_SMELL</type>
    <name>"catch" clauses should do more than rethrow</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A <code>catch</code> clause that only rethrows the caught exception has the same effect as omitting the <code>catch</code> altogether and letting
it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads. </p>
<p>Such clauses should either be eliminated or populated with the appropriate logic.</p>
<h2>Noncompliant Code Example</h2>
<pre>
string s = "";
try
{
  s = File.ReadAllText(fileName);
}
catch (Exception e)  // Noncompliant
{
  throw;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
string s = "";
try
{
  s = File.ReadAllText(fileName);
}
catch (Exception e) // Compliant
{
  logger.LogError(e);
  throw;
}
</pre>
<p>or</p>
<pre>
string s = File.ReadAllText(fileName);
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>unused</tag>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3928</key>
    <type>CODE_SMELL</type>
    <name>Parameter names used into ArgumentException constructors should match an existing one </name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Some constructors of the <code>ArgumentException</code>, <code>ArgumentNullException</code>, <code>ArgumentOutOfRangeException</code> and
<code>DuplicateWaitObjectException</code> classes must be fed with a valid parameter name. This rule raises an issue in two cases:</p>
<ul>
  <li> When this parameter name doesn't match any existing ones. </li>
  <li> When a call is made to the default (parameterless) constructor </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
public void Foo(Bar a, int[] b)
{
  throw new ArgumentException(); // Noncompliant
  throw new ArgumentException("My error message", "c"); // Noncompliant
  throw new ArgumentException("My error message", "c", innerException); // Noncompliant
  throw new ArgumentNullException("c"); // Noncompliant
  throw new ArgumentNullException("My error message", "c"); // Noncompliant
  throw new ArgumentOutOfRangeException("c");
  throw new ArgumentOutOfRangeException("c", "My error message"); // Noncompliant
  throw new ArgumentOutOfRangeException("c", b, "My error message"); // Noncompliant
}
</pre>
<h2>Exceptions</h2>
<p>The rule won't raise an issue if the parameter name is not a constant value (inline declaration, nameof() or const variable).</p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1451</key>
    <type>CODE_SMELL</type>
    <name>Track lack of copyright and license headers</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Each source file should start with a header stating file ownership and the license which must be used to distribute the application. </p>
<p>This rule must be fed with the header text that is expected at the beginning of every file.</p>
<p>The <code>headerFormat</code> must end with an empty line if you want to have an empty line between the file header and the first line for your
source file (<code>using</code>, <code>namespace</code>...).</p>
<p>For example, if you want the source file to look like this</p>
<pre>
// Copyright (c) SonarSource. All Rights Reserved. Licensed under the LGPL License.  See License.txt in the project root for license information.

namespace Foo
{
}
</pre>
<p>then the <code>headerFormat</code> parameter should end with an empty line like this</p>
<pre>
// Copyright (c) SonarSource. All Rights Reserved. Licensed under the LGPL License.  See License.txt in the project root for license information.

</pre>
<h2>Compliant Solution</h2>
<pre>
/*
 * SonarQube, open source software quality management tool.
 * Copyright (C) 2008-2013 SonarSource
 * mailto:contact AT sonarsource DOT com
 *
 * SonarQube is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * SonarQube is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
</pre>

]]></description>
    <param>
      <key>headerFormat</key>
      <description><![CDATA[Expected copyright and license header.]]></description>
      <type>STRING</type>
      <defaultValue>/*
 * SonarQube, open source software quality management tool.
 * Copyright (C) 2008-2013 SonarSource
 * mailto:contact AT sonarsource DOT com
 *
 * SonarQube is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * SonarQube is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
</defaultValue>
    </param>
    <param>
      <key>isRegularExpression</key>
      <description><![CDATA[Whether the headerFormat is a regular expression.]]></description>
      <type>BOOLEAN</type>
      <defaultValue>false</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S101</key>
    <type>CODE_SMELL</type>
    <name>Types should be named in camel case</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not type names are camel cased. To reduce noise, two
consecutive upper case characters are allowed unless they form the whole type name. So, <code>MyXClass</code> is compliant, but <code>XC</code> on its
own is not.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class my_class {...}
class SOMEName42 {...}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass {...}
class SomeName42 {...}
</pre>
<h2>Exceptions</h2>
<p>The rule ignores types that are marked with <code>ComImportAttribute</code> or <code>InterfaceTypeAttribute</code>. Furthermore, the rule allows to
have <code>'_'</code> characters in class names inside test projects.</p>
<pre>
class Some_Name___42 {...} // valid in test
class Some_name___42 {...} // still not valid
class Some_Name_XC {...} // invalid because of XC, should be Some_Name_Xc
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3453</key>
    <type>BUG</type>
    <name>Classes should not have only "private" constructors</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A class with only <code>private</code> constructors can't be instantiated, thus, it seems to be pointless code.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass // Noncompliant
{
  private MyClass() { ... }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MyClass
{
  public MyClass() { ... }
}
</pre>
<h2>Exceptions</h2>
<p>Classes that themselves access their private constructors (singletons or smart enums) are ignored. Classes with only <code>static</code> members
are also ignored because they are covered by Rule S1118.</p>

]]></description>
    <tag>design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1694</key>
    <type>CODE_SMELL</type>
    <name>An abstract class should have both abstract and concrete methods</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes.</p>
<p>A class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a concrete class (i.e. remove the
<code>abstract</code> keyword) with a private constructor.</p>
<p>A class with only abstract methods and no inheritable behavior should be converted to an interface.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public abstract class Animal //Noncompliant; should be an interface
{
  abstract void Move();
  abstract void Feed();
}

public abstract class Color //Noncompliant; should be concrete with a private constructor
{
  private int red = 0;
  private int green = 0;
  private int blue = 0;

  public int GetRed()
  {
    return red;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public interface Animal
{
  void Move();
  void Feed();
}

public class Color
{
  private int red = 0;
  private int green = 0;
  private int blue = 0;

  private Color()
  {}

  public int GetRed()
  {
    return red;
  }
}

public abstract class Lamp
{
  private bool switchLamp = false;

  public abstract void Glow();

  public void FlipSwitch()
  {
    switchLamp = !switchLamp;
    if (switchLamp)
    {
      Glow();
    }
  }
}
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3897</key>
    <type>CODE_SMELL</type>
    <name>Classes that provide "Equals(&lt;T&gt;)" or override "Equals(Object)" should implement "IEquatable&lt;T&gt;"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>IEquatable&lt;T&gt;</code> interface has only one method in it: <code>Equals(&lt;T&gt;)</code>. If you've already written
<code>Equals(T)</code>, there's no reason not to explicitly implement <code>IEquatable&lt;T&gt;</code>. Doing so expands the utility of your class by
allowing it to be used where an <code>IEquatable</code> is called for.</p>
<p>Similarly, having written <code>Equals(&lt;T&gt;)</code>, it's not that much further to go to write <code>Equals(Object)</code> and vice versa;
just a couple more lines brings a large dividend of functionality. So this rule raises an issue when <code>Equals(&lt;T&gt;)</code> is not accompanied
by <code>IEquatable</code> and <code>Equals(Object)</code>, and vice versa.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass  // Noncompliant
{
  public override bool Equals(object other)
  {
    //...
  }
}
</pre>
<pre>
class MyClass  // Noncompliant
{
  public bool Equals(MyClass other)
  {
    //...
  }
}
</pre>
<pre>
class MyClass : IEquatable&lt;T&gt;  // Noncompliant
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass : IEquatable&lt;MyClass&gt;
{
  public override bool Equals(object other)
  {
    return Equals(other as MyClass);
  }

  public bool Equals(MyClass other)
  {
    //...
  }
}
</pre>

]]></description>
    <tag>api-design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1118</key>
    <type>CODE_SMELL</type>
    <name>Utility classes should not have public constructors</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Utility classes, which are collections of <code>static</code> members, are not meant to be instantiated. Even <code>abstract</code> utility
classes, which can be extended, should not have <code>public</code> constructors.</p>
<p>C# adds an implicit public constructor to every class which does not explicitly define at least one constructor. Hence, at least one
<code>protected</code> constructor should be defined if you wish to subclass this utility class. Or the <code>static</code> keyword should be added to
the class declaration to prevent subclassing.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class StringUtils // Noncompliant
{
  public static string Concatenate(string s1, string s2)
  {
    return s1 + s2;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public static class StringUtils
{
  public static string Concatenate(string s1, string s2)
  {
    return s1 + s2;
  }
}
</pre>
<p>or</p>
<pre>
public class StringUtils
{
  protected StringUtils()
  {
  }
  public static string Concatenate(string s1, string s2)
  {
    return s1 + s2;
  }
}
</pre>
<h2>Exceptions</h2>
<p>When class contains <code>public static void main(String[] args)</code> method it is not considered as utility class and will be ignored by this
rule.</p>

]]></description>
    <tag>design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3776</key>
    <type>CODE_SMELL</type>
    <name>Cognitive Complexity of methods should not be too high</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be
difficult to maintain.</p>
<h2>See</h2>
<ul>
  <li> <a href="http://redirect.sonarsource.com/doc/cognitive-complexity.html">Cognitive Complexity</a> </li>
</ul>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>threshold</key>
      <description><![CDATA[The maximum authorized complexity.]]></description>
      <type>INTEGER</type>
      <defaultValue>15</defaultValue>
    </param>
    <param>
      <key>propertyThreshold </key>
      <description><![CDATA[The maximum authorized complexity in a property.]]></description>
      <type>INTEGER</type>
      <defaultValue>3</defaultValue>
    </param>
    <remediationFunctionBaseEffort />
  </rule>
  <rule>
    <key>S1155</key>
    <type>CODE_SMELL</type>
    <name>"Any()" should be used to test for emptiness</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using <code>.Count()</code> to test for emptiness works, but using <code>.Any()</code> makes the intent clearer, and the code more readable.
However, there are some cases where special attention should be paid:</p>
<p>- if the collection is an <code>EntityFramework</code> or other ORM query, calling <code>.Count()</code> will cause executing a potentially massive
SQL query and could put a large overhead on the application database. Calling <code>.Any()</code> will also connect to the database, but will generate
much more efficient SQL.</p>
<p>- if the collection is part of a LINQ query that contains <code>.Select()</code> statements that create objects, a large amount of memory could be
unnecessarily allocated. Calling <code>.Any()</code> will be much more efficient because it will execute fewer iterations of the enumerable.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private static bool HasContent(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() &gt; 0;  // Noncompliant
}

private static bool HasContent2(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() &gt;= 1;  // Noncompliant
}

private static bool IsEmpty(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() == 0;  // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
private static bool HasContent(IEnumerable&lt;string&gt; strings)
{
  return strings.Any();
}

private static bool IsEmpty(IEnumerable&lt;string&gt; strings)
{
  return !strings.Any();
}
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4004</key>
    <type>CODE_SMELL</type>
    <name>Collection properties should be readonly</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A writable collection property can be replaced by a completely different collection. Making it <code>readonly</code> prevents that while still
allowing individual members to be set. If you want to allow the replacement of the whole collection the recommended pattern is to implement a method
to remove all the elements (e.g. <code>System.Collections.List&lt;T&gt;.Clear</code>) and a method to populate the collection (e.g.
<code>System.Collections.List&lt;T&gt;.AddRange</code>).</p>
<p>This rule raises an issue when an externally visible writable property is of a type that implements <code>System.Collections.ICollection</code> or
<code>System.Collections.Generic.ICollection&lt;T&gt;</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;
using System.Collections;

namespace MyLibrary
{
  public class Foo
  {
    List&lt;string&gt; strings;

    public List&lt;string&gt; SomeStrings
    {
      get { return strings; }
      set { strings = value; } // Noncompliant
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;
using System.Collections;

namespace MyLibrary
{
  public class Foo
  {
    List&lt;string&gt; strings;

    public readonly List&lt;string&gt; SomeStrings
    {
      get { return strings; }
    }
  }
}
</pre>
<h2>Exceptions</h2>
<p>This rule does not raise issues for <code>string</code>, <code>Array</code> and <code>PermissionSet</code>.</p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2971</key>
    <type>CODE_SMELL</type>
    <name>"IEnumerable" LINQs should be simplified</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways <code>IEnumerable
LINQ</code>s can be simplified</p>
<ul>
  <li> Use <code>OfType</code> instead of using <code>Select</code> with <code>as</code> to type cast elements and then null-checking in a query
  expression to choose elements based on type. </li>
  <li> Use <code>OfType</code> instead of using <code>Where</code> and the <code>is</code> operator, followed by a cast in a <code>Select</code> </li>
  <li> Use an expression in <code>Any</code> instead of <code>Where(element =&gt; [expression]).Any()</code>. </li>
  <li> Use <code>Count</code> instead of <code>Count()</code> when it's available. </li>
  <li> Don't call <code>ToArray()</code> or <code>ToList()</code> in the middle of a query chain. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
seq1.Select(element =&gt; element as T).Any(element =&gt; element != null);  // Noncompliant; use OfType
seq2.Select(element =&gt; element as T).Any(element =&gt; element != null &amp;&amp; CheckCondition(element));  // Noncompliant; use OfType
seq3.Where(element =&gt; element is T).Select(element =&gt; element as T); // Noncompliant; use OfType
seq4.Where(element =&gt; element is T).Select(element =&gt; (T)element); // Noncompliant; use OfType
seq5.Where(element =&gt; [expression]).Any();  // Noncompliant; use Any([expression])

var num = seq6.Count(); // Noncompliant
var arr = seq.ToList().ToArray(); //Noncompliant
var count = seq.ToList().Count(x=&gt;[condition]); //Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
seq1.OfType&lt;T&gt;().Any();
seq2.OfType&lt;T&gt;().Any(element =&gt; CheckCondition(element));
seq3.OfType&lt;T&gt;();
seq4.OfType&lt;T&gt;();
seq5.Any(element =&gt; [expression])

var num = seq6.Count;
var arr = seq.ToArray();
var count = seq.Count(x=&gt;[condition]);
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3909</key>
    <type>CODE_SMELL</type>
    <name>Collections should implement the generic interface</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The NET Framework 2.0 introduced the generic interface <code>System.Collections.Generic.IEnumerable&lt;T&gt;</code> and it should be preferred over
the older, non generic, interfaces.</p>
<p>This rule raises an issue when a public type implements <code>System.Collections.IEnumerable</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;
using System.Collections;

public class MyData
{
  public MyData()
  {
  }
}

public class MyList : CollectionBase // Noncompliant
{
  public void Add(MyData data)
  {
    InnerList.Add(data);
  }

  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;
using System.Collections.ObjectModel;

public class MyData
{
  public MyData()
  {
  }
}

public class MyList : Collection&lt;MyData&gt;
{
  // Implementation...
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S125</key>
    <type>CODE_SMELL</type>
    <name>Sections of code should not be "commented out"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Programmers should not comment out code as it bloats programs and reduces readability.</p>
<p>Unused code should be deleted and can be retrieved from source control history if required.</p>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 2.4 - Sections of code should not be "commented out". </li>
  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be "commented out" using C-style comments. </li>
  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be "commented out" using C++ comments. </li>
  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be "commented out" </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1134</key>
    <type>CODE_SMELL</type>
    <name>Track uses of "FIXME" tags</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</p>
<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>
<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private int Divide(int numerator, int denominator)
{
  return numerator / denominator;              // FIXME denominator value might be  0
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/546.html">MITRE, CWE-546</a> - Suspicious Comment </li>
</ul>

]]></description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>S1135</key>
    <type>CODE_SMELL</type>
    <name>Track uses of "TODO" tags</name>
    <severity>INFO</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>
<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>
<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private void DoSomething()
{
  // TODO
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/546.html">MITRE, CWE-546</a> - Suspicious Comment </li>
</ul>

]]></description>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>S1210</key>
    <type>CODE_SMELL</type>
    <name>"Equals" and the comparison operators should be overridden when implementing "IComparable"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When you implement <code>IComparable</code> or <code>IComparable&lt;T&gt;</code> on a class you should also override <code>Equals(object)</code>
and overload the comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code>). That's because the CLR cannot automatically call your <code>CompareTo</code> implementation from <code>Equals(object)</code> or
from the base comparison operator implementations. Additionally, it is best practice to override <code>GetHashCode</code> along with
<code>Equals</code>.</p>
<p>This rule raises an issue when a class implements <code>IComparable</code> without also overriding <code>Equals(object)</code> and the comparison
operators.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo: IComparable  // Noncompliant
{
  public int CompareTo(object obj) { /* ... */ }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo: IComparable
{
  public int CompareTo(object obj) { /* ... */ }
  public override bool Equals(object obj)
  {
    var other = obj as Foo;
    if (object.ReferenceEquals(other, null))
    {
      return false;
    }
    return this.CompareTo(other) == 0;
  }
  public int GetHashCode() { /* ... */ }
  public static bool operator == (Foo left, Foo right)
  {
    if (object.ReferenceEquals(left, null))
    {
      return object.ReferenceEquals(right, null);
    }
    return left.Equals(right);
  }
  public static bool operator &gt; (Foo left, Foo right)
  {
    return Compare(left, right) &gt; 0;
  }
  public static bool operator &lt; (Foo left, Foo right)
  {
    return Compare(left, right) &lt; 0;
  }
  public static bool operator != (Foo left, Foo right)
  {
    return !(left == right);
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2688</key>
    <type>BUG</type>
    <name>"NaN" should not be used in comparisons</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>NaN</code> is not equal to anything, even itself. Testing for equality or inequality against <code>NaN</code> will yield predictable results,
but probably not the ones you want. </p>
<p>Instead, the best way to see whether a variable is equal to <code>NaN</code> is to use <code>Number.isNaN()</code>, since ES2015, or (perhaps
counter-intuitively) to compare it to itself. Since <code>NaN !== NaN</code>, when <code>a !== a</code>, you know it must equal <code>NaN</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
var a = double.NaN;

if (a == double.NaN) // Noncompliant; always false
{
  Console.WriteLine("a is not a number");  // this is dead code
}
if (a != double.NaN)  // Noncompliant; always true
{
  Console.WriteLine("a is not NaN"); // this statement is not necessarily true
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (double.IsNaN(a))
{
  console.log("a is not a number");
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/7AEqAQ">CERT, NUM07-J.</a> - Do not attempt comparisons with NaN </li>
</ul>

]]></description>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3240</key>
    <type>CODE_SMELL</type>
    <name>The simplest possible condition syntax should be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means </p>
<ul>
  <li> using the <code>??</code> operator for an assign-if-not-null operator, </li>
  <li> using the ternary operator <code>?:</code> for assignment to a single variable, and </li>
  <li> removing the <code>??</code> when the left operand is known to be <code>null</code>, or known to be definitely not <code>null</code>. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
object a = null, b = null, x;

if (a != null) // Noncompliant; needlessly verbose
{
  x = a;
}
else
{
  x = b;
}

x = a != null ? a : b; // Noncompliant; better but could still be simplified

x = (a == null) ? new object() : a; // Noncompliant

if (condition) // Noncompliant
{
  x = a;
}
else
{
  x = b;
}

var y = null ?? new object(); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
object x;

x = a ?? b;
x = a ?? b;
x = a ?? new object();
x = condition ? a : b;
var y = new object();
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1862</key>
    <type>BUG</type>
    <name>Related "if/else if" statements should not have the same condition</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first
one with a condition that evaluates to <code>true</code>. </p>
<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and
at worst, it's a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior. </p>
<h2>Noncompliant Code Example</h2>
<pre>
if (param == 1)
{
  OpenWindow();
}
else if (param == 2)
{
  CloseWindow();
}
else if (param == 1) // Noncompliant
{
  MoveWindowToTheBackground();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (param == 1)
{
  OpenWindow();
}
else if (param == 2)
{
  CloseWindow();
}
else if (param == 3)
{
  MoveWindowToTheBackground();
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>unused</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1871</key>
    <type>CODE_SMELL</type>
    <name>Two branches in a conditional structure should not have exactly the same implementation</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Having two <code>cases</code> in the same <code>switch</code> statement or branches in the same <code>if</code> structure with the same
implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an
<code>if</code> structure they should be combined, or for a <code>switch</code>, one should fall through to the other.</p>
<h2>Noncompliant Code Example</h2>
<pre>
switch (i)
{
  case 1:
    DoSomething();
    break;
  case 2:
    DoSomethingDifferent();
    break;
  case 3:  // Noncompliant; duplicates case 1's implementation
    DoSomething();
    break;
  default:
    DoTheRest();
}

if (a &gt;= 0 &amp;&amp; a &lt; 10)
{
  DoTheThing();
}
else if (a &gt;= 10 &amp;&amp; a &lt; 20)
{
  DoTheOtherThing();
}
else if (a &gt;= 20 &amp;&amp; a &lt; 50)
{
  DoTheThing();  // Noncompliant; duplicates first condition
}
else
{
  DoTheRest();
}

if (b == 0)
{
  DoOneMoreThing();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
switch (i) {
  case 1:
  case 3:
    DoSomething();
    break;
  case 2:
    DoSomethingDifferent();
    break;
  default:
    DoTheRest();
}

if ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50))
{
  DoTheThing();
}
else if (a &gt;= 10 &amp;&amp; a &lt; 20)
{
  DoTheOtherThing();
}
else
{
  DoTheRest();
}

DoOneMoreThing();
</pre>
<p>or</p>
<pre>
switch (i)
{
  case 1:
    DoSomething();
    break;
  case 2:
    DoSomethingDifferent();
    break;
  case 3:
    DoThirdThing();
    break;
  default:
    DoTheRest();
}

if (a &gt;= 0 &amp;&amp; a &lt; 10)
{
  DoTheThing();
}
else if (a &gt;= 10 &amp;&amp; a &lt; 20)
{
  DoTheOtherThing();
}
else if (a &gt;= 20 &amp;&amp; a &lt; 50)
{
  DoTheThirdThing();
}
else
{
  DoTheRest();
}
</pre>
<h2>Exceptions</h2>
<p>Blocks in an <code>if</code> chain that contain a single line of code are ignored, as are blocks in a <code>switch</code> statement that contain a
single line of code with or without a following <code>break</code>.</p>

]]></description>
    <tag>design</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2760</key>
    <type>CODE_SMELL</type>
    <name>Sequential tests should not check the same condition</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should
have been checked in the second test.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (a == b)
{
  doTheThing(b);
}
if (a == b) // Noncompliant; is this really what was intended?
{
  doTheThing(c);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (a == b)
{
  doTheThing(b);
  doTheThing(c);
}
</pre>
<p>or</p>
<pre>
if (a == b)
{
  doTheThing(b);
}
if (b == c)
{
  doTheThing(c);
}
</pre>
<h2>Exceptions</h2>
<p>Since it is a common pattern to test a variable, reassign it if it fails the test, then re-test it, that pattern is ignored.</p>

]]></description>
    <tag>suspicious</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2583</key>
    <type>BUG</type>
    <name>Conditionally executed blocks should be reachable</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Conditional expressions which are always <code>true</code> or <code>false</code> can lead to dead code. Such code is always buggy and should never
be used in production.</p>
<h2>Noncompliant Code Example</h2>
<pre>
a = false;
if (a) // Noncompliant
{
  DoSomething(); // never executed
}

if (!a || b) // Noncompliant; "!a" is always "true", "b" is never evaluated
{
  DoSomething();
}
else
{
  DoSomethingElse(); // never executed
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>
  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/570.html">MITRE, CWE-570</a> - Expression is Always False </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/571">MITRE, CWE-571</a> - Expression is Always True </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>unused</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2589</key>
    <type>CODE_SMELL</type>
    <name>Boolean expressions should not be gratuitous</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>If a boolean expression doesn't change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous
because it does not match the programmer's intent, then it's a bug and the expression should be fixed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
a = true;
if (a) // Noncompliant
{
  DoSomething();
}

if (b &amp;&amp; a) // Noncompliant; "a" is always "true"
{
  DoSomething();
}

if (c || !a) // Noncompliant; "!a" is always "false"
{
  DoSomething();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
a = true;
if (Foo(a))
{
  DoSomething();
}

if (b)
{
  DoSomething();
}

if (c)
{
  DoSomething();
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>
  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/489">MITRE, CWE-489</a> - Leftover Debug Code </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/571">MITRE, CWE-571</a> - Expression is Always True </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>redundant</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2228</key>
    <type>VULNERABILITY</type>
    <name>Console logging should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Debug statements are always useful during development. But include them in production code - particularly in code that runs client-side - and you
run the risk of inadvertently exposing sensitive information.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private void DoSomething ()
{
  // ...
  Console.WriteLine ("so far, so good..."); // Noncompliant
  // ...
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure
  </li>
</ul>

]]></description>
    <tag>owasp-a6</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1699</key>
    <type>CODE_SMELL</type>
    <name>Constructors should only call non-overridable methods</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the
method.</p>
<p>For example:</p>
<ul>
  <li> The subclass class constructor starts by calling the parent class constructor. </li>
  <li> The parent class constructor calls the method, which has been overridden in the child class. </li>
  <li> If the behavior of the child class method depends on fields that are initialized in the child class constructor, unexpected behavior (like a
  <code>NullReferenceException</code>) can result, because the fields aren't initialized yet. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
public class Parent
{
  public Parent()
  {
    DoSomething();  // Noncompliant
  }

  public virtual void DoSomething() // can be overridden
  {
    ...
  }
}

public class Child : Parent
{
  private string foo;

  public Child(string foo) // leads to call DoSomething() in Parent constructor which triggers a NullReferenceException as foo has not yet been initialized
  {
    this.foo = foo;
  }

  public override void DoSomething()
  {
    Console.WriteLine(this.foo.Length);
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/MYYbAQ">CERT, MET05-J.</a> - Ensure that constructors do not call overridable methods
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/TQBi">CERT, OOP50-CPP.</a> - Do not invoke virtual functions from constructors or
  destructors </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1854</key>
    <type>CODE_SMELL</type>
    <name>Dead stores should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value
only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources.
Therefore all calculated values should be used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void CalculateRate(int a, int b)
{
  int i;

  i = a + b; // Noncompliant; calculation result not used before value is overwritten
  i = DoSomething();  // Noncompliant; retrieved value not used
  for (i = 0; i &lt; 10; i++)
  {
    //  ...
  }
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void CalculateRate(int a, int b)
{
  int i;

  i = DoSomething();
  i += a + b;
  StoreI(i);

  for (i = 0; i &lt; 10; i++)
  {
    //  ...
  }
}
</pre>
<h2>Exceptions</h2>
<p>No issue is reported when </p>
<ul>
  <li> the analyzed method body contains <code>try</code> blocks, </li>
  <li> a lambda expression captures the local variables, or </li>
  <li> the variable is unused (case covered by Rule S1481) </li>
  <li> initializations to <code>-1</code>, <code>0</code>, <code>1</code>, <code>null</code>, <code>true</code>, <code>false</code>, <code>""</code>
  and <code>string.Empty</code>. </li>
</ul>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/563.html">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/QYA5">CERT, MSC13-C.</a> - Detect and remove unused values </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/S4IyAQ">CERT, MSC13-CPP.</a> - Detect and remove unused values </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/uQCSBg">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3346</key>
    <type>BUG</type>
    <name>Expressions used in "Debug.Assert" should not produce side effects</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>An assertion is a piece of code that’s used during development when the compilation debug mode is activated. It allows a program to check itself as
it runs. When an assertion is true, that means everything is operating as expected. </p>
<p>In non-debug mode, all <code>Debug.Assert</code> are automatically left out. So, by contract, the boolean expressions that are evaluated by those
assertions must absolutely not contain any side effects. Otherwise, when leaving the Debug mode, the functional behavior of the application is not the
same anymore.</p>
<h2>Noncompliant Code Example</h2>
<pre>
Debug.Assert(list.Remove("dog"));
</pre>
<h2>Compliant Solution</h2>
<pre>
bool result = list.Remove("dog");
Debug.Assert(result);
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/vwG7AQ">CERT, EXP06-J.</a> - Expressions used in assertions must not produce side
  effects </li>
</ul>

]]></description>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3906</key>
    <type>CODE_SMELL</type>
    <name>Event Handlers should have the correct signature</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Delegate event handlers (i.e. delegates used as type of an event) should have a very specific signature:</p>
<ul>
  <li> Return type <code>void</code>. </li>
  <li> First argument of type <code>System.Object</code> and named 'sender'. </li>
  <li> Second argument of type <code>System.EventArgs</code> (or any derived type) and is named 'e'. </li>
</ul>
<p>This rule raises an issue whenever a <code>delegate</code> declaration doesn't match that signature.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public delegate void AlarmEventHandler(object s);

public class Foo
{
    public event AlarmEventHandler AlarmEvent; // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public delegate void AlarmEventHandler(object sender, AlarmEventArgs e);

public class Foo
{
    public event AlarmEventHandler AlarmEvent; // Compliant
}
</pre>
<h2>See</h2>
<p><a href="https://msdn.microsoft.com/en-us/library/edzehd2t.aspx">Handling and Raising Events</a></p>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3903</key>
    <type>BUG</type>
    <name>Types should be defined in named namespaces</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are
defined outside any named namespace are in a global namespace that cannot be referenced in code.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo // Noncompliant
{
}

public struct Bar // Noncompliant
{
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3172</key>
    <type>BUG</type>
    <name>Delegates should not be subtracted</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.</p>
<p>Subtracting a chain of delegates from another one might yield unexpected results as shown hereunder - and is likely to be a bug.</p>
<h2>Noncompliant Code Example</h2>
<pre>
MyDelegate first, second, third, fourth;
first = () =&gt; Console.Write("1");
second = () =&gt; Console.Write("2");
third = () =&gt; Console.Write("3");
fourth = () =&gt; Console.Write("4");

MyDelegate chain1234 = first + second + third + fourth; // Compliant - chain sequence = "1234"
MyDelegate chain12 = chain1234 - third - fourth; // Compliant - chain sequence = "12"


MyDelegate chain14 = first + fourth; // creates a new MyDelegate instance which is a list under the covers
MyDelegate chain23 = chain1234 - chain14; // Noncompliant; (first + fourth) doesn't exist in chain1234


// The chain sequence of "chain23" will be "1234" instead of "23"!
// Indeed, the sequence "1234" does not contain the subsequence "14", so nothing is subtracted
// (but note that "1234" contains both the "1" and "4" subsequences)
chain23 = chain1234 - (first + fourth); // Noncompliant

chain23(); // will print "1234"!
</pre>
<h2>Compliant Solution</h2>
<pre>
MyDelegate chain23 = chain1234 - first - fourth; // Compliant - "1" is first removed, followed by "4"

chain23(); // will print "23"
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2931</key>
    <type>BUG</type>
    <name>Classes with "IDisposable" members should implement "IDisposable"</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Classes with <code>IDisposable</code> members are responsible for cleaning up those members by calling their <code>Dispose</code> methods. The best
practice here is for the owning class to itself implement <code>IDisposable</code> and call its members' <code>Dispose</code> methods from its own
<code>Dispose</code> method.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class ResourceHolder   // Noncompliant; doesn't implement IDisposable
{
  private FileStream fs;  // This member is never Dispose'd
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class ResourceHolder : IDisposable
{
&nbsp;&nbsp;private FileStream fs;
&nbsp;&nbsp;public void OpenResource(string path)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.fs = new FileStream(path, FileMode.Open);
&nbsp;&nbsp;}
&nbsp;&nbsp;public void CloseResource()
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.fs.Close();
&nbsp;&nbsp;}

&nbsp;&nbsp;public void Dispose()
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.fs.Dispose();
&nbsp;&nbsp;}
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/459.html">MITRE, CWE-459</a> - Incomplete Cleanup </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>denial-of-service</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2930</key>
    <type>BUG</type>
    <name>"IDisposables" should be disposed</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When writing managed code, you don't need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency
reasons, some objects such as <code>Bitmap</code> use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have
potentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed
footprint, and fails to reclaim the unmanaged memory (by calling <code>Bitmap</code>'s finalizer method) in a timely fashion. </p>
<p>Moreover, memory is not the only system resource which needs to be managed in a timely fashion: The operating system can only handle having so many
file descriptors (e.g. <code>FileStream</code>) or sockets (e.g. <code>WebClient</code>) open at any given time. Therefore, it is important to
<code>Dispose</code> of them as soon as they are no longer needed, rather than relying on the garbage collector to call these objects' finalizers at
some nondeterministic point in the future.</p>
<p>This rule tracks <code>private</code> fields and local variables of the following <code>IDisposable</code> types, which are never disposed, closed,
aliased, returned, or passed to other methods.</p>
<ul>
  <li> <code>System.IO</code> namespace
    <ul>
      <li> <code>System.IO.FileStream</code> </li>
      <li> <code>System.IO.StreamReader</code> </li>
      <li> <code>System.IO.StreamWriter</code> </li>
    </ul> </li>
  <li> <code>System.Net</code> namespace
    <ul>
      <li> <code>System.Net.WebClient</code> </li>
    </ul> </li>
  <li> <code>System.Net.Sockets</code> namespace
    <ul>
      <li> <code>System.Net.Sockets.Socket</code> </li>
      <li> <code>System.Net.Sockets.TcpClient</code> </li>
      <li> <code>System.Net.Sockets.UdpClient</code> </li>
    </ul> </li>
  <li> <code>System.Drawing</code> namespace
    <ul>
      <li> <code>System.Drawing.Image</code> </li>
      <li> <code>System.Drawing.Bitmap</code> </li>
    </ul> </li>
</ul>
<p>which are either instantiated directly using the <code>new</code> operator, or using one of the following factory methods:</p>
<ul>
  <li> <code>System.IO.File.Create()</code> </li>
  <li> <code>System.IO.File.Open()</code> </li>
  <li> <code>System.Drawing.Image.FromFile()</code> </li>
  <li> <code>System.Drawing.Image.FromStream()</code> </li>
</ul>
<p>on both private fields and local variables.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class ResourceHolder
{
  private FileStream fs; // Noncompliant; Dispose or Close are never called

  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }

  public void WriteToFile(string path, string text)
  {
    var fs = new FileStream(path, FileMode.Open); // Noncompliant
    var bytes = Encoding.UTF8.GetBytes(text);
    fs.Write(bytes, 0, bytes.Length);
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;

  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }

  public void Dispose()
  {
    this.fs.Dispose();
  }

  public void WriteToFile(string path, string text)
  {
    using (var fs = new FileStream(path, FileMode.Open))
    {
      var bytes = Encoding.UTF8.GetBytes(text);
      fs.Write(bytes, 0, bytes.Length);
    }
  }
}
</pre>
<h2>Exceptions</h2>
<p><code>IDisposable</code> variables returned from a method or passed to other methods are ignored, as are local <code>IDisposable</code>s that are
initialized with other <code>IDisposable</code>s.</p>
<pre>
public Stream WriteToFile(string path, string text)
{
  var fs = new FileStream(path, FileMode.Open); // Compliant, because it is returned
  var bytes = Encoding.UTF8.GetBytes(text);
  fs.Write(bytes, 0, bytes.Length);
  return fs;
}

public void ReadFromStream(Stream s)
{
  var sr = new StreamReader(s); // Compliant as it would close the underlying stream.
  // ...
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/459.html">MITRE, CWE-459</a> - Incomplete Cleanup </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>denial-of-service</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2997</key>
    <type>BUG</type>
    <name>"IDisposables" created in a "using" statement should not be returned</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Typically you want to use <code>using</code> to create a local <code>IDisposable</code> variable; it will trigger disposal of the object when
control passes out of the block's scope. The exception to this rule is when your method returns that <code>IDisposable</code>. In that case
<code>using</code> disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove
<code>using</code> or avoid returning the <code>IDisposable</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public FileStream WriteToFile(string path, string text)
{
  using (var fs = File.Create(path)) // Noncompliant
  {
    var bytes = Encoding.UTF8.GetBytes(text);
    fs.Write(bytes, 0, bytes.Length);
    return fs;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public FileStream WriteToFile(string path, string text)
{
  var fs = File.Create(path);
  var bytes = Encoding.UTF8.GetBytes(text);
  fs.Write(bytes, 0, bytes.Length);
  return fs;
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4002</key>
    <type>CODE_SMELL</type>
    <name>Disposable types should declare finalizers</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>This rule raises an issue when a disposable type contains fields of the following types and does not implement a finalizer:</p>
<ul>
  <li> <code>System.IntPtr</code> </li>
  <li> <code>System.UIntPtr</code> </li>
  <li> <code>System.Runtime.InteropService.HandleRef</code> </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
using System;
using System.Runtime.InteropServices;

namespace MyLibrary
{
  public class Foo : IDisposable // Noncompliant: Doesn't have a finalizer
  {
    private IntPtr myResource;
    private bool disposed = false;

    protected virtual void Dispose(bool disposing)
    {
      if (!disposed)
      {
        // Dispose of resources held by this instance.
        FreeResource(myResource);
        disposed = true;

        // Suppress finalization of this disposed instance.
        if (disposing)
        {
          GC.SuppressFinalize(this);
        }
      }
    }

    public void Dispose() {
      Dispose(true);
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;
using System.Runtime.InteropServices;

namespace MyLibrary
{
  public class Foo : IDisposable
  {
    private IntPtr myResource;
    private bool disposed = false;

    protected virtual void Dispose(bool disposing)
    {
      if (!disposed)
      {
        // Dispose of resources held by this instance.
        FreeResource(myResource);
        disposed = true;

        // Suppress finalization of this disposed instance.
        if (disposing)
        {
          GC.SuppressFinalize(this);
        }
      }
    }

    ~Foo()
    {
      Dispose(false);
    }
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> Related: {rule:csharpsquid:S3881} - "IDisposable" should be implemented correctly </li>
</ul>

]]></description>
  </rule>
  <rule>
    <key>S2952</key>
    <type>BUG</type>
    <name>Classes should "Dispose" of members from the classes' own "Dispose" methods</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>It is possible in an <code>IDisposable</code> to call <code>Dispose</code> on class members from any method, but the contract of
<code>Dispose</code> is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource
leaks.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }

  public void CleanUp()
  {
    this.fs.Dispose(); // Noncompliant; Dispose not called in class' Dispose method
  }

  public void Dispose()
  {
    // method added to satisfy demands of interface
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }

  public void Dispose()
  {
    this.fs.Dispose();
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/459.html">MITRE, CWE-459</a> - Incomplete Cleanup </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>denial-of-service</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2953</key>
    <type>CODE_SMELL</type>
    <name>Methods named "Dispose" should implement "IDisposable.Dispose"</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>Dispose</code> as a method name should be used exclusively to implement <code>IDisposable.Dispose</code> to prevent any confusion.</p>
<p>It may be tempting to create a <code>Dispose</code> method for other purposes, but doing so will result in confusion and likely lead to problems in
production.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class GarbageDisposal
{
  private int Dispose()  // Noncompliant
  {
    // ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class GarbageDisposal : IDisposable
{
  public void Dispose()
  {
    // ...
  }
}
</pre>
<p>or</p>
<pre>
public class GarbageDisposal
{
  private int Grind()
  {
    // ...
  }
}
</pre>
<h2>Exceptions</h2>
<p>Methods named <code>Dispose</code> and invoked from the <code>IDisposable.Dispose</code> implementation are not reported.</p>
<pre>
public class GarbageDisposal  :  IDisposable
{
  protected virtual void Dispose(bool disposing)
  {
    //...
  }
  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3902</key>
    <type>CODE_SMELL</type>
    <name>"Assembly.GetExecutingAssembly" should not be called</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using <code>Type.Assembly</code> to get the current assembly is nearly free in terms of performance; it's a simple property access. On the other
hand, <code>Assembly.GetExecutingAssembly()</code> can take up to 30 times as long because it walks up the call stack to find the assembly.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Example
{
   public static void Main()
   {
      Assembly assem = Assembly.GetExecutingAssembly(); // Noncompliant
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Example
{
   public static void Main()
   {
      Assembly assem = typeof(Example).Assembly; // Here we use the type of the current class
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3885</key>
    <type>CODE_SMELL</type>
    <name>"Assembly.Load" should be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The parameter to <code>Assembly.Load</code> includes the full specification of the dll to be loaded. Use another method, and you might end up with
a dll other than the one you expected. </p>
<p>This rule raises an issue when <code>Assembly.LoadFrom</code>, <code>Assembly.LoadFile</code>, or <code>Assembly.LoadWithPartialName</code> is
called.</p>
<h2>Noncompliant Code Example</h2>
<pre>
static void Main(string[] args)
{
    Assembly.LoadFrom(...); // Noncompliant
    Assembly.LoadFile(...); // Noncompliant
    Assembly.LoadWithPartialName(...); // Noncompliant + deprecated
}
</pre>

]]></description>
    <tag>unpredictable</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3869</key>
    <type>BUG</type>
    <name>"SafeHandle.DangerousGetHandle" should not be called</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Not surprisingly, the <code>SafeHandle.DangerousGetHandle</code> method is dangerous. That's because it may not return a valid handle. Using it can
lead to leaks and vulnerabilities. While it is possible to use the method successfully, it's extremely difficult to do correctly, so the method should
simply be avoided altogether.</p>
<h2>Noncompliant Code Example</h2>
<pre>
static void Main(string[] args)
{
    System.Reflection.FieldInfo fieldInfo = ...;
    SafeHandle handle = (SafeHandle)fieldInfo.GetValue(rKey);
    IntPtr dangerousHandle = handle.DangerousGetHandle();  // Noncompliant
}
</pre>

]]></description>
    <tag>leak</tag>
    <tag>unpredictable</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1215</key>
    <type>CODE_SMELL</type>
    <name>"GC.Collect" should not be called</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Calling <code>GC.Collect</code> is rarely necessary, and can significantly affect application performance. That's because it triggers a blocking
operation that examines <em>every object in memory</em> for cleanup. Further, you don't have control over when this blocking cleanup will actually
run.</p>
<p>As a general rule, the consequences of calling this method far outweigh the benefits unless perhaps you've just triggered some event that is unique
in the run of your program that caused a lot of long-lived objects to die.</p>
<p>This rule raises an issue when <code>GC.Collect</code> is invoked.</p>
<h2>Noncompliant Code Example</h2>
<pre>
static void Main(string[] args)
{
  // ...
  GC.Collect(2, GCCollectionMode.Optimized); // Noncompliant
}
</pre>

]]></description>
    <tag>performance</tag>
    <tag>unpredictable</tag>
    <tag>bad-practice</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3971</key>
    <type>CODE_SMELL</type>
    <name>"GC.SuppressFinalize" should not be called</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>GC.SuppressFinalize</code> requests that the system not call the finalizer for the specified object. This should only be done when
implementing <code>Dispose</code> as part of the <a href="https://msdn.microsoft.com/en-us/library/b1yfkh5e.aspx">Dispose Pattern</a>.</p>
<p>This rule raises an issue when <code>GC.SuppressFinalize</code> is called outside that pattern.</p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3889</key>
    <type>BUG</type>
    <name>Neither "Thread.Resume" nor "Thread.Suspend" should be used</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>Thread.Suspend</code> and <code>Thread.Resume</code> can give unpredictable results, and both methods have been deprecated. Indeed, if
<code>Thread.Suspend</code> is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer
synchronization mechanisms should be used, such as <code>Monitor</code>, <code>Mutex</code>, and <code>Semaphore</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
static void Main(string[] args)
{
  // ...
  Thread.CurrentThread.Suspend(); // Noncompliant
  Thread.CurrentThread.Resume(); // Noncompliant
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://msdn.microsoft.com/en-us/library/system.threading.thread.resume.aspx">Thread.Resume Method ()</a> </li>
  <li> <a href="https://msdn.microsoft.com/en-us/library/system.threading.thread.suspend(v=vs.110).aspx">Thread.Suspend Method ()</a> </li>
</ul>

]]></description>
    <tag>multi-threading</tag>
    <tag>unpredictable</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3981</key>
    <type>BUG</type>
    <name>Collection sizes and array length comparisons should make sense</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The size of a collection and the length of an array are always greater than or equal to zero. So testing that a size or length is greater than or
equal to zero doesn't make sense, since the result is always <code>true</code>. Similarly testing that it is less than zero will always return
<code>false</code>. Perhaps the intent was to check the non-emptiness of the collection or array instead. </p>
<h2>Noncompliant Code Example</h2>
<pre>
if(collection.Count &gt;= 0){...}

if(enumerable.Count() &lt; 0){...}

if(array.Length &gt;= 0){...}

bool result = array.Length &gt;=0;
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2365</key>
    <type>CODE_SMELL</type>
    <name>Properties should not make collection or array copies</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will
be much slower than a simple field access, contrary to the caller's likely expectations. Therefore, such properties should be refactored into methods
so that callers are not surprised by unexpectedly poor performance.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private List&lt;string&gt; _foo = new List&lt;string&gt; { "a", "b", "c" };
public IEnumerable&lt;string&gt; Foo  // Noncompliant
{
    get
    {
        return _foo.ToList();
    }
}

private string[] _bar = new string[] { "a", "b", "c" };
public IEnumerable&lt;string&gt; Bar // Noncompliant
{
    get
    {
        return (string[])_bar.Clone();
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
private List&lt;string&gt; _foo = new List&lt;string&gt; { "a", "b", "c" };
private string[] _bar = new string[] { "a", "b", "c" };

public IEnumerable&lt;string&gt; GetFoo()
{
    return _foo.ToList();
}

public IEnumerable&lt;string&gt; GetBar()
{
    return (string[])_bar.Clone();
}
</pre>

]]></description>
    <tag>api-design</tag>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4015</key>
    <type>CODE_SMELL</type>
    <name>Inherited member visibility should not be decreased</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Changing an inherited member to <code>private</code> will not prevent access to the base class implementation.</p>
<p>This rule raises an issue when a <code>private</code>, non-<code>final</code> method in an unsealed type has a signature that is identical to a
<code>public</code> method declared in a base type.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
  public class Foo
  {
    public void SomeMethod(int count) { }
  }
  public class Bar:Foo
  {
    private void SomeMethod(int count) { } // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
  public class Foo
  {
    public void SomeMethod(int count) { }
  }
  public class Bar:Foo
  {
    private final void SomeMethod(int count) { }
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2068</key>
    <type>VULNERABILITY</type>
    <name>Credentials should not be hard-coded</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they're almost guaranteed to
end up in the hands of an attacker. This is particularly true for applications that are distributed.</p>
<p>Credentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.</p>
<h2>Noncompliant Code Example</h2>
<pre>
string username = "admin";
string password = "Password123"; // Noncompliant
string usernamePassword  = "user=admin&amp;password=Password123"; // Noncompliant
string usernamePassword2 = "user=admin&amp;" + "password=" + password; // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
string username = "admin";
string password = GetEncryptedPassword();
string usernamePassword = string.Format("user={0}&amp;password={1}", GetEncryptedUsername(), GetEncryptedPassword());
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/798">MITRE, CWE-798</a> - Use of Hard-coded Credentials </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/259">MITRE, CWE-259</a> - Use of Hard-coded Password </li>
  <li> <a href="http://www.sans.org/top25-software-errors/">SANS Top 25</a> - Porous Defenses </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/qQCHAQ">CERT, MSC03-J.</a> - Never hard code sensitive information </li>
  <li> <a href="https://www.owasp.org/index.php/Top_10_2013-A2-Broken_Authentication_and_Session_Management">OWASP Top Ten 2013 Category A2</a> -
  Broken Authentication and Session Management </li>
  <li> Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#HARD_CODE_PASSWORD">Hard Coded Password</a> </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>cert</tag>
    <tag>sans-top25-porous</tag>
    <tag>owasp-a2</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4019</key>
    <type>CODE_SMELL</type>
    <name>Base class methods should not be hidden</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When a method in a derived class has the same name as a method in the base class but with a signature that only differs by types that are weakly
derived (e.g. <code>object</code> vs <code>string</code>), the result is that the base method becomes hidden.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
  class Foo
  {
    internal void SomeMethod(string s1, string s2) { }
  }

  class Bar : Foo
  {
    internal void SomeMethod(string s1, object o2) { }  // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
  class Foo
  {
    internal void SomeMethod(string s1, string s2) { }
  }

  class Bar : Foo
  {
    internal void SomeOtherMethod(string s1, object o2) { }
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3998</key>
    <type>CODE_SMELL</type>
    <name>Threads should not lock on objects with weak identity</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A thread acquiring a lock on an object that can be accessed across application domain boundaries runs the risk of being blocked by another thread
in a different application domain. Objects that can be accessed across application domain boundaries are said to have weak identity. Types with weak
identity are:</p>
<ul>
  <li> <code>MarshalByRefObject</code> </li>
  <li> <code>ExecutionEngineException</code> </li>
  <li> <code>OutOfMemoryException</code> </li>
  <li> <code>StackOverflowException</code> </li>
  <li> <code>String</code> </li>
  <li> <code>MemberInfo</code> </li>
  <li> <code>ParameterInfo</code> </li>
  <li> <code>Thread</code> </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
using System;
using System.Threading;

namespace MyLibrary
{
  class Foo
  {
    string myString = "foo";

    void Bar()
    {
      lock(myString) { } // Noncompliant
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;
using System.Threading;

namespace MyLibrary
{
  class Foo
  {
    string myString = "foo";
    private readonly Object thisLock = new Object();

    void Bar()
    {
      lock(thisLock) { } // Compliant
    }
  }
}
</pre>

]]></description>
    <tag>multi-threading</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4017</key>
    <type>CODE_SMELL</type>
    <name>Method signatures should not contain nested generic types</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A nested type is a type argument that is also a generic type. Calling a method with such a nested type argument requires complicated and confusing
code. It should be avoided as much as possible.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;
using System.Collections.Generic;

namespace MyLibrary
{
  public class Foo
  {
    public void DoSomething(ICollection&lt;ICollection&lt;int&gt;&gt; outerCollect) // Noncompliant
    {
    }
  }
}
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3874</key>
    <type>CODE_SMELL</type>
    <name>"out" and "ref" parameters should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Passing a parameter by reference, which is what happens when you use the <code>out</code> or <code>ref</code> parameter modifiers, means that the
method will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change
the argument's values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when
it is what was intended, this is the sort of thing that's difficult to get right, and should be used with caution.</p>
<p>This rule raises an issue when <code>out</code> or <code>ref</code> is used on a non-<code>Optional</code> parameter in a public method.
<code>Optional</code> parameters are covered by S3447.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void GetReply(
         ref MyClass input, // Noncompliant
         out string reply)  // Noncompliant
{ ... }
</pre>
<h2>Compliant Solution</h2>
<pre>
public string GetReply(MyClass input)
{ ... }

public bool TryGetReply(MyClass input, out string reply)
{ ... }

public ReplyData GetReply(MyClass input)
{ ... }

internal void GetReply(ref MyClass input, out string reply)
{ ... }
</pre>
<h2>Exceptions</h2>
<p>This rule will not raise issues for:</p>
<p>- non-public methods</p>
<p>- methods with only 'out' parameters, name starting with "Try" and return type bool.</p>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3875</key>
    <type>CODE_SMELL</type>
    <name>"operator==" should not be overloaded on reference types</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The use of <code>==</code> to compare to objects is expected to do a reference comparison. That is, it is expected to return <code>true</code> if
and only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by
callers. On the other hand, overloading it to do exactly that is pointless; that's what <code>==</code> does by default.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public static bool operator== (MyType x, MyType y) // Noncompliant
{
</pre>
<h2>Exceptions</h2>
<ul>
  <li> Classes with overloaded <code>operator +</code> or <code>operator -</code> methods are ignored. </li>
  <li> Classes that implement <code>IComparable&lt;T&gt;</code> or <code>IEquatable&lt;T&gt;</code> most probably behave as a value-type objects and
  so are ignored. </li>
</ul>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1186</key>
    <type>CODE_SMELL</type>
    <name>Methods should not be empty</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>There are several reasons for a method not to have a method body:</p>
<ul>
  <li> It is an unintentional omission, and should be fixed. </li>
  <li> It is not yet, or never will be, supported. In this case a <code>NotSupportedException</code> should be thrown. </li>
  <li> The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
public override void DoSomething()
{
}

public override void DoSomethingElse()
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public override void DoSomething()
{
  // Do nothing because of X and Y.
}

public override void DoSomethingElse()
{
  throw new NotSupportedException();
}
</pre>
<h2>Exceptions</h2>
<p>The following methods are ignored:</p>
<ul>
  <li> empty <code>virtual</code> methods, </li>
  <li> empty methods that override an <code>abstract</code> method, </li>
  <li> empty overrides in test assemblies. </li>
</ul>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3261</key>
    <type>CODE_SMELL</type>
    <name>Namespaces should not be empty</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Namespaces with no lines of code clutter a project and should be removed. </p>
<h2>Noncompliant Code Example</h2>
<pre>
namespace MyEmptyNamespace // Noncompliant
{

}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/OYIyAQ">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S108</key>
    <type>CODE_SMELL</type>
    <name>Nested blocks of code should not be left empty</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
for (int i = 0; i &lt; 42; i++){}  // Empty on purpose or missing piece of code ?
</pre>
<h2>Exceptions</h2>
<p>When a block contains a comment, this block is not considered to be empty.</p>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3655</key>
    <type>BUG</type>
    <name>Empty nullable value should not be accessed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Nullable value types can hold either a value or <code>null</code>. The value held in the nullable type can be accessed with the <code>Value</code>
property, but <code>.Value</code> throws an <code>InvalidOperationException</code> when the value is <code>null</code>. To avoid the exception, a
nullable type should always be tested before <code>.Value</code> is accessed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int? nullable = null;
...
UseValue(nullable.Value); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
int? nullable = null;
...
if (nullable.HasValue)
{
  UseValue(nullable.Value);
}
</pre>
<p>or</p>
<pre>
int? nullable = null;
...
if (nullable != null)
{
  UseValue(nullable.Value);
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/476.html">MITRE, CWE-476</a> - NULL Pointer Dereference </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1116</key>
    <type>CODE_SMELL</type>
    <name>Empty statements should be removed</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Empty statements, i.e. <code>;</code>, are usually introduced by mistake, for example because:</p>
<ul>
  <li> It was meant to be replaced by an actual statement, but this was forgotten. </li>
  <li> There was a typo which lead the semicolon to be doubled, i.e. <code>;;</code>. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
void doSomething()
{
  ; // Noncompliant - was used as a kind of TODO marker
}

void doSomethingElse()
{
  Console.WriteLine("Hello, world!");;  // Noncompliant - double ;
  ...
  // Rarely, they are used on purpose as the body of a loop. It is a bad practice to
  // have side-effects outside of the loop:
  for (int i = 0; i &lt; 3; Console.WriteLine(i), i++); // Noncompliant
  ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void doSomething()
{
}

void doSomethingElse()
{
  Console.WriteLine("Hello, world!");
  ...
  for (int i = 0; i &lt; 3; i++)
  {
    Console.WriteLine(i);
   }
  ...
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that
  the first character following the null statement is a white-space character. </li>
  <li> MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided
  that the first character following the null statement is a white-space character. </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/7gCTAw">CERT, MSC51-J.</a> - Do not place a semicolon immediately following an if, for,
  or while condition </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/i4FtAg">CERT, EXP15-C.</a> - Do not place a semicolon on the same line as an if, for,
  or while statement </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2291</key>
    <type>CODE_SMELL</type>
    <name>Overflow checking should not be disabled for "Enumerable.Sum"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>Enumerable.Sum()</code> always executes addition in a <code>checked</code> context, so an <code>OverflowException</code> will be thrown if
the value exceeds <code>MaxValue</code> even if an <code>unchecked</code> context was specified. Using an <code>unchecked</code> context anyway
represents a misunderstanding of how <code>Sum</code> works.</p>
<p>This rule raises an issue when an <code>unchecked</code> context is specified for a <code>Sum</code> on integer types.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void Add(List&lt;int&gt; list)
{
  int d = unchecked(list.Sum());  // Noncompliant

  unchecked
  {
    int e = list.Sum();  // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void Add(List&lt;int&gt; list)
{
  int d = list.Sum();

  try
  {
    int e = list.Sum();
  }
  catch (System.OverflowException e)
  {
    // exception handling...
  }
}
</pre>
<h2>Exceptions</h2>
<p>When the <code>Sum()</code> call is inside a <code>try-catch</code> block, no issues are reported.</p>
<pre>
void Add(List&lt;int&gt; list)
{
  unchecked
  {
    try
    {
      int e = list.Sum();
    }
    catch (System.OverflowException e)
    {
      // exception handling...
    }
  }
}
</pre>

]]></description>
    <tag>error-handling</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2344</key>
    <type>CODE_SMELL</type>
    <name>Enumeration type names should not have "Flags" or "Enum" suffixes</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.</p>
<h2>Noncompliant Code Example</h2>
<pre>
enum FooFlags // Noncompliant
{
    Foo = 1
    Bar = 2
    Baz = 4
}
</pre>
<h2>Compliant Solution</h2>
<pre>
enum Foo
{
    Foo = 1
    Bar = 2
    Baz = 4
}
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2342</key>
    <type>CODE_SMELL</type>
    <name>Enumeration types should comply with a naming convention</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all <code>enum</code> names match a provided regular
expression.</p>
<p>The default configuration is the one recommended by Microsoft:</p>
<ul>
  <li> Pascal casing, starting with an upper case character, e.g. BackColor </li>
  <li> Short abbreviations of 2 letters can be capitalized, e.g. GetID </li>
  <li> Longer abbreviations need to be lower case, e.g. GetHtml </li>
  <li> If the enum is marked as [Flags] then its name should be plural (e.g. MyOptions), otherwise, names should be singular (e.g. MyOption) </li>
</ul>
<h2>Noncompliant Code Example</h2>
<p>With the default regular expression for non-flags enums: <code>^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?$</code></p>
<pre>
public enum foo // Noncompliant
{
    FooValue = 0
}
</pre>
<p>With the default regular expression for flags enums: <code>^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?s$</code></p>
<pre>
[Flags]
public enum Option // Noncompliant
{
    None = 0,
    Option1 = 1,
    Option2 = 2
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public enum Foo
{
    FooValue = 0
}
</pre>
<pre>
[Flags]
public enum Options
{
    None = 0,
    Option1 = 1,
    Option2 = 2
}
</pre>

]]></description>
    <tag>convention</tag>
    <param>
      <key>format</key>
      <description><![CDATA[Regular expression used to check the enumeration type names against.]]></description>
      <type>STRING</type>
      <defaultValue>^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?$</defaultValue>
    </param>
    <param>
      <key>flagsAttributeFormat</key>
      <description><![CDATA[Regular expression used to check the flags enumeration type names against.]]></description>
      <type>STRING</type>
      <defaultValue>^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?s$</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4016</key>
    <type>CODE_SMELL</type>
    <name>Enumeration members should not be named "Reserved"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>If an <code>enum</code> member's name contains the word "reserved" it implies it is not currently used and will be change in the future. However
changing an <code>enum</code> member is a breaking change and can create significant problems. There is no need to reserve an <code>enum</code> member
since a new member can be added in the future, and such an addition will usually not be a breaking change.</p>
<p>This rule raises an issue when the name of an enumeration member contains "reserved".</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
  public enum Color
  {
        None,
        Red,
        Orange,
        Yellow,
        ReservedColor  // Noncompliant
    }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4022</key>
    <type>CODE_SMELL</type>
    <name>Enumerations should have "Int32" storage</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>By default the storage type of an <code>enum</code> is <code>Int32</code>. In most cases it is not necessary to change this. In particular you will
not achieve any performance gain by using a smaller data type (e.g. <code>Byte</code>) and may limit future uses.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
    public enum Visibility : sbyte // Noncompliant
    {
        Visible = 0,
        Invisible = 1,
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
    public enum Visibility
    {
        Visible = 0,
        Invisible = 1,
    }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1244</key>
    <type>BUG</type>
    <name>Floating point numbers should not be tested for equality</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is
not associative; push a <code>float</code> or a <code>double</code> through a series of simple mathematical operations and the answer will be
different based on the order of those operation because of the rounding that takes place at each step.</p>
<p>Even simple floating point assignments are not simple:</p>
<pre>
float f = 0.100000001f; // 0.1
double d = 0.10000000000000001; // 0.1
</pre>
<p>(Results will vary based on compiler and compiler settings)</p>
<p>Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on <code>float</code> or <code>double</code> values
is almost always an error.</p>
<p>This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.</p>
<h2>Noncompliant Code Example</h2>
<pre>
float myNumber = 3.146f;
if ( myNumber == 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false
{
  // ...
}

if (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // Noncompliant indirect equality test
{
  // ...
}

if (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test
{
  // ...
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. </li>
  <li> MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality </li>
</ul>

]]></description>
    <tag>misra</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2197</key>
    <type>CODE_SMELL</type>
    <name>Modulus results should not be checked for direct equality</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for
equality with a positive number (or a negative one) could result in unexpected results. </p>
<h2>Noncompliant Code Example</h2>
<pre>
public bool IsOdd(int x)
{
  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public bool IsOdd(int x)
{
  return x %2 != 0;
}
</pre>
<p>or</p>
<pre>
public bool IsOdd(uint x)
{
  return x %2 == 1;
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/xAHAAQ">CERT, NUM51-J.</a> - Do not assume that the remainder operator always returns a
  nonnegative result for integral operands </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NQBi">CERT, INT10-C</a> - Do not assume a positive remainder when using the % operator
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/_YBLAQ">CERT, INT10-CPP.</a> - Do not assume a positive remainder when using the %
  operator </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3445</key>
    <type>CODE_SMELL</type>
    <name>Exceptions should not be explicitly rethrown</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When rethrowing an exception, you should do it by simply calling <code>throw;</code> and not <code>throw exc;</code>, because the stack trace is
reset with the second syntax, making debugging a lot harder.</p>
<h2>Noncompliant Code Example</h2>
<pre>
try
{}
catch(ExceptionType1 exc)
{
  Console.WriteLine(exc);
  throw exc; // Noncompliant; stacktrace is reset
}
catch (ExceptionType2 exc)
{
  throw new Exception("My custom message", exc);  // Compliant; stack trace preserved
}
</pre>
<h2>Compliant Solution</h2>
<pre>
try
{}
catch(ExceptionType1 exc)
{
  Console.WriteLine(exc);
  throw;
}
catch (ExceptionType2 exc)
{
  throw new Exception("My custom message", exc);
}
</pre>

]]></description>
    <tag>error-handling</tag>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3877</key>
    <type>CODE_SMELL</type>
    <name>Exceptions should not be thrown from unexpected methods</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>It is expected that some methods should be called with caution, but others, such as <code>ToString</code>, are expected to "just work". Throwing an
exception from such a method is likely to break callers' code unexpectedly.</p>
<p>An issue is raised when an exception is thrown from any of the following: </p>
<ul>
  <li> Event accessors </li>
  <li> <code>Object.Equals</code> </li>
  <li> <code>IEquatable.Equals</code> </li>
  <li> <code>GetHashCode</code> </li>
  <li> <code>ToString</code> </li>
  <li> <code>static</code> constructors </li>
  <li> <code>IDisposable.Dispose</code> </li>
  <li> <code>operator ==, !=, &lt;, &gt;, &lt;=, &gt;=</code> </li>
  <li> <code>implicit</code> cast operators </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
public override string ToString()
{
  if (string.IsNullOrEmpty(Name))
  {
    throw new ArgumentException("...");  // Noncompliant
  }
  //...
</pre>
<h2>Exceptions</h2>
<p><code>System.NotImplementedException</code> and its derivatives are ignored.</p>
<p><code>System.InvalidOperationException</code>, <code>System.NotSupportedException</code>, and <code>System.ArgumentException</code> and their
derivatives are ignored in event accessors.</p>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4027</key>
    <type>CODE_SMELL</type>
    <name>Exceptions should provide standard constructors</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Exceptions types should provide the following constructors:</p>
<ul>
  <li> <code>public MyException()</code> </li>
  <li> <code>public MyException(string)</code> </li>
  <li> <code>public MyException(string, Exception)</code> </li>
  <li> <code>protected</code> or <code>private MyException(SerializationInfo, StreamingContext)</code> </li>
</ul>
<p>That fourth constructor should be <code>protected</code> in unsealed classes, and <code>private</code> in sealed classes.</p>
<p>Not having this full set of constructors can make it difficult to handle exceptions.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
  public class MyException // Noncompliant: several constructors are missing
  {
    public MyException()
    {
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;
using System.Runtime.Serialization;

namespace MyLibrary
{
  public class MyException : Exception
  {
      public MyException()
      {
      }

      public MyException(string message)
          :base(message)
      {
      }

      public MyException(string message, Exception innerException)
          : base(message, innerException)
      {
      }

      protected MyException(SerializationInfo info, StreamingContext context)
          : base(info, context)
      {
      }
  }
}
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3871</key>
    <type>CODE_SMELL</type>
    <name>Exception types should be "public"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be
<code>public</code> for that to work. </p>
<p>If a method throws a non-public exception, the best you can do on the caller's side is to <code>catch</code> the closest <code>public</code> base
of the class. That is, you lose all that custom information you created the exception type to pass. </p>
<h2>Noncompliant Code Example</h2>
<pre>
internal class MyException : Exception   // Noncompliant
{
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MyException : Exception
{
  // ...
}
</pre>
<h2>Exceptions</h2>
<p>This rule ignores Exception types that are not derived directly from <code>System.Exception</code>, <code>System.SystemException</code>, or
<code>System.ApplicationException</code>.</p>

]]></description>
    <tag>error-handling</tag>
    <tag>api-design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3984</key>
    <type>BUG</type>
    <name>Exception should not be created without being thrown </name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Creating a new <code>Exception</code> without actually throwing it is useless and is probably due to a mistake.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (x &lt; 0)
{
  new ArgumentException("x must be nonnegative");
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (x &lt; 0)
{
  throw new ArgumentException("x must be nonnegative");
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1067</key>
    <type>CODE_SMELL</type>
    <name>Expressions should not be too complex</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The complexity of an expression is defined by the number of <code>&amp;&amp;</code>, <code>||</code> and <code>condition ? ifTrue : ifFalse</code>
operators it contains.</p>
<p>A single expression's complexity should not become too high to keep the code readable.</p>
<h2>Noncompliant Code Example</h2>
<p>With the default threshold value of 3</p>
<pre>
if (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... }
</pre>
<h2>Compliant Solution</h2>
<pre>
if ((MyFirstCondition() || MySecondCondition()) &amp;&amp; MyLastCondition()) { ... }
</pre>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>max</key>
      <description><![CDATA[Maximum number of allowed conditional operators in an expression]]></description>
      <type>INTEGER</type>
      <defaultValue>3</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>3min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2387</key>
    <type>CODE_SMELL</type>
    <name>Child class fields should not shadow parent class fields</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you'll get confusion at
best, chaos at worst. </p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...
}

public class Raspberry : Fruit
{
  private bool ripe; // Noncompliant
  private static Color FLESH; // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...
}

public class Raspberry : Fruit
{
  private bool ripened;
  private static Color FLESH_COLOR;
}
</pre>
<h2>Exceptions</h2>
<p>This rule ignores same-name fields that are <code>static</code> in both the parent and child classes. It also ignores <code>private</code> parent
class fields, but in all other such cases, the child class field should be renamed.</p>
<pre>
public class Fruit
{
  private Season ripe;
  // ...
}

public class Raspberry : Fruit
{
  private Season ripe;  // Compliant as parent field 'ripe' is anyway not visible from Raspberry
  // ...
}
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4025</key>
    <type>CODE_SMELL</type>
    <name>Child class fields should not differ from parent class fields only be capitalization</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Having a field in a child class with a name that differs from a parent class' field only by capitalization is sure to cause confusion. Such child
class fields should be renamed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Fruit
{
  protected string plantingSeason;
  //...
}

public class Raspberry : Fruit
{
  protected string plantingseason;  // Noncompliant
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Fruit
{
  protected string plantingSeason;
  //...
}

public class Raspberry : Fruit
{
  protected string whenToPlant;
  // ...
}
</pre>
<p>Or</p>
<pre>
public class Fruit
{
  protected string plantingSeason;
  //...
}

public class Raspberry : Fruit
{
  // field removed; parent field will be used instead
  // ...
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2933</key>
    <type>CODE_SMELL</type>
    <name>Fields that are only assigned in the constructor should be "readonly"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>readonly</code> fields can only be assigned in a class constructor. If a class has a field that's not marked <code>readonly</code> but is
only set in the constructor, it could cause confusion about the field's intended use. To avoid confusion, such fields should be marked
<code>readonly</code> to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Person
{
  int _birthYear;  // Noncompliant
  Person(int birthYear)
  {
    _birthYear = birthYear;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Person
{
  readonly int _birthYear;
  Person(int birthYear)
  {
    _birthYear = birthYear;
  }
}
</pre>
<h2>Exceptions</h2>
<p>Fields with attributes are ignored.</p>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2357</key>
    <type>CODE_SMELL</type>
    <name>Fields should be private</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Fields should not be part of an API, and therefore should always be private. Indeed, they cannot be added to an interface for instance, and
validation cannot be added later on without breaking backward compatiblity. Instead, developers should encapsulate their fields into properties.
Explicit property getters and setters can be introduced for validation purposes or to smooth the transition to a newer system.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
  public int MagicNumber = 42;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo
{
  public int MagicNumber
  {
    get { return 42; }
  }
}
</pre>
<p>or </p>
<pre>
public class Foo
{
  private int MagicNumber = 42;
}
</pre>
<h2>Exceptions</h2>
<p><code>struct</code>s are ignored, as are <code>static</code> and <code>const</code> fields in classes. </p>
<p>Further, an issue is only raised when the real accessibility is <code>public</code>, taking into account the class accessibility.</p>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1104</key>
    <type>VULNERABILITY</type>
    <name>Fields should not have public accessibility</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Public fields in public classes do not respect the encapsulation principle and has three main disadvantages:</p>
<ul>
  <li> Additional behavior such as validation cannot be added. </li>
  <li> The internal representation is exposed, and cannot be changed afterwards. </li>
  <li> Member values are subject to change from anywhere in the code and may not meet the programmer's assumptions. </li>
</ul>
<p>By using private fields and public properties (set and get), unauthorized modifications are prevented. Properties also benefit from additional
protection (security) features such as Link Demands.</p>
<p>Note that due to optimizations on simple properties, public fields provide only very little performance gain.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
    public int instanceData = 32; // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo
{
    private int instanceData = 32;

    public int InstanceData
    {
        get { return instanceData; }
	set { instanceData = value ; }
    }
}
</pre>
<h2>Exceptions</h2>
<p>Fields marked as <code>readonly</code> or <code>const</code> are ignored by this rule.</p>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/493.html">MITRE, CWE-493</a> - Critical Public Variable Without Final Modifier </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S104</key>
    <type>CODE_SMELL</type>
    <name>Files should not have too many lines of code</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to
maintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those
smaller files will not only be easier to understand but also probably easier to test.</p>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>maximumFileLocThreshold</key>
      <description><![CDATA[Maximum authorized lines in a file.]]></description>
      <type>INTEGER</type>
      <defaultValue>1000</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1h</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3880</key>
    <type>CODE_SMELL</type>
    <name>Finalizers should not be empty</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no
benefit or justification.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
    ~Foo() // Noncompliant
    {
    }
}
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2345</key>
    <type>BUG</type>
    <name>Flags enumerations should explicitly initialize all their members</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization will set the first member to
0, and increment the value by one for each subsequent member. This implicit behavior does not allow members to be combined using the bitwise or
operator in a useful way.</p>
<p>Instead, 0 and powers of two (i.e. 1, 2, 4, 8, 16, ...) should be used to explicitly initialize all the members.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[Flags]
enum FruitType    // Noncompliant
{
  None,
  Banana,
  Orange,
  Strawberry
}
class Program
{
    static void Main()
    {
        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;
        // Will display only Strawberry!
        Console.WriteLine(bananaAndStrawberry.ToString());
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
[Flags]
enum FruitType
{
  None = 0,
  Banana = 1,
  Orange = 2,
  Strawberry = 4
}
class Program
{
    static void Main()
    {
        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;
        // Will display Banana and Strawberry, as expected.
        Console.WriteLine(bananaAndStrawberry.ToString());
    }
}
</pre>
<h2>Exceptions</h2>
<p>The default initialization of 0, 1, 2, 3, 4, ... matches 0, 1, 2, 4, 8 ... in the first three values, so no issue is reported if the first three
members of the enumeration is not initialized.</p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2346</key>
    <type>CODE_SMELL</type>
    <name>Flags enumerations zero-value members should be named "None"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Consisitent use of "None" in flags enumerations indicates that all flag values are cleared. The value 0 should not be used to indicate any other
state, since there is no way to check that the bit <code>0</code> is set.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[Flags]
enum FruitType
{
    Void = 0,        // Non-Compliant
    Banana = 1,
    Orange = 2,
    Strawberry = 4
}
</pre>
<h2>Compliant Solution</h2>
<pre>
[Flags]
enum FruitType
{
    None = 0,        // Compliant
    Banana = 1,
    Orange = 2,
    Strawberry = 4
}
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3217</key>
    <type>CODE_SMELL</type>
    <name>"Explicit" conversions of "foreach" loops should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>foreach</code> statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections
available at that time such as <code>ArrayList</code>. The <code>foreach</code> statements allows you to downcast elements of a collection of
<code>Object</code>s to any other type. The problem is that to achieve the cast, the <code>foreach</code> statements silently performs
<code>explicit</code> type conversion, which at runtime can result in an <code>InvalidCastException</code>.</p>
<p>C# code iterating on generic collections or arrays should not rely on <code>foreach</code> statement's silent <code>explicit</code>
conversions.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Fruit { }
public class Orange : Fruit { }
public class Apple : Fruit { }

class MyTest
{
  public void Test()
  {
    var fruitBasket = new List&lt;Fruit&gt;();
    fruitBasket.Add(new Orange());
    fruitBasket.Add(new Orange());
    // fruitBasket.Add(new Apple());  // uncommenting this line will make both foreach below throw an InvalidCastException

    foreach (Fruit fruit in fruitBasket)
    {
      var orange = (Orange)fruit; // This "explicit" conversion is hidden within the foreach loop below
      ...
    }

    foreach (Orange orange in fruitBasket) // Noncompliant
    {
      ...
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
var fruitBasket = new List&lt;Orange&gt;();
fruitBasket.Add(new Orange());
fruitBasket.Add(new Orange());
// fruitBasket.Add(new Apple());  // uncommenting this line won't compile

foreach (Orange orange in fruitBasket)
{
  ...
}
</pre>
<p>or</p>
<pre>
var fruitBasket = new List&lt;Fruit&gt;();
fruitBasket.Add(new Orange());
fruitBasket.Add(new Orange());
fruitBasket.Add(new Apple());

foreach (Orange orange in fruitBasket.OfType&lt;Orange&gt;())
{
  ...
}
</pre>
<h2>Exceptions</h2>
<p>The rule ignores iterations on collections of <code>object</code>s. This includes legacy code that uses <code>ArrayList</code>. Furthermore, the
rule does not report on cases when user defined conversions are being called. </p>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S127</key>
    <type>CODE_SMELL</type>
    <name>"for" loop stop conditions should be invariant</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A <code>for</code> loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and
ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins. </p>
<p>Stop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the
introduction of errors in the future.</p>
<p>This rule tracks three types of non-invariant stop conditions:</p>
<ul>
  <li> When the loop counters are updated in the body of the <code>for</code> loop </li>
  <li> When the stop condition depend upon a method call </li>
  <li> When the stop condition depends on an object property, since such properties could change during the execution of the loop. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
class Foo
{
    static void Main()
    {
        for (int i = 1; i &lt;= 5; i++)
        {
            Console.WriteLine(i);
            if (condition)
            {
               i = 20;
           }
        }
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Foo
{
    static void Main()
    {
        for (int i = 1; i &lt;= 5; i++)
        {
            Console.WriteLine(i);
        }
    }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 13.6 - Numeric variables being used within a <em>for</em> loop for iteration counting shall not be modified in the body of the
  loop. </li>
  <li> MISRA C++:2008, 6-5-3 - The <em>loop-counter</em> shall not be modified within <em>condition</em> or <em>statement</em>. </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1994</key>
    <type>CODE_SMELL</type>
    <name>"for" loop increment clauses should modify the loops' counters</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>It can be extremely confusing when a <code>for</code> loop's counter is incremented outside of its increment clause. In such cases, the increment
should be moved to the loop's increment clause if at all possible.</p>
<h2>Noncompliant Code Example</h2>
<pre>
for (i = 0; i &lt; 10; j++) // Noncompliant
{
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
for (i = 0; i &lt; 10; i++)
{
  // ...
}
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3376</key>
    <type>CODE_SMELL</type>
    <name>Attribute, EventArgs, and Exception type names should end with the type being extended</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, <code>class FirstAttribute :
Attribute</code> can be used simply with <code>First</code>, but you must use the full name for <code>class AttributeOne : Attribute</code>.</p>
<p>This rule raises an issue when classes extending <code>Attribute</code>, <code>EventArgs</code>, or <code>Exception</code>, do not end with their
parent class names.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class AttributeOne : Attribute  // Noncompliant
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class FirstAttribute : Attribute
{
}
</pre>
<h2>Exceptions</h2>
<p>If a class' direct base class doesn't follow the convention, then no issue is reported on the class itself, regardless of whether or not it
conforms to the convention.</p>
<pre>
class Timeout : Exception // Noncompliant
{
}
class ExtendedTimeout : Timeout // Ignored; doesn't conform to convention, but the direct base doesn't conform either
{
}
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1541</key>
    <type>CODE_SMELL</type>
    <name>Methods and properties should not be too complex</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be
difficult to understand and therefore to maintain.</p>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>maximumFunctionComplexityThreshold</key>
      <description><![CDATA[The maximum authorized complexity.]]></description>
      <type>INTEGER</type>
      <defaultValue>10</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S134</key>
    <type>CODE_SMELL</type>
    <name>Control flow statements "if", "switch", "for", "foreach", "while", "do"  and "try" should not be nested too deeply</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Nested <code>if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do</code>, and <code>try</code>
statements are key ingredients for making what's known as "Spaghetti code".</p>
<p>Such code is hard to read, refactor and therefore maintain.</p>
<h2>Noncompliant Code Example</h2>
<p>With the default threshold of 3:</p>
<pre>
if (condition1) // Compliant - depth = 1
{
  /* ... */
  if (condition2) // Compliant - depth = 2
  {
    /* ... */
    for(int i = 0; i &lt; 10; i++) // Compliant - depth = 3, not exceeding the limit
    {
      /* ... */
      if (condition4) // Noncompliant - depth = 4
      {
        if (condition5) // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
        {
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>max</key>
      <description><![CDATA[Maximum allowed control flow statement nesting depth.]]></description>
      <type>INTEGER</type>
      <defaultValue>3</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2934</key>
    <type>BUG</type>
    <name>Property assignments should not be made for "readonly" fields not constrained to reference types</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>While the properties of a <code>readonly</code> reference type field can still be changed after initialization, those of a <code>readonly</code>
value field, such as a <code>struct</code>, cannot. </p>
<p>If the member could be either a <code>class</code> or a <code>struct</code> then assignment to its properties could be unreliable, working
sometimes but not others.</p>
<h2>Noncompliant Code Example</h2>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T: IPoint
{
  readonly T point;  // this could be a struct
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX)
  {
    point.X = newX; //Noncompliant; if point is a struct, then nothing happened
    Console.WriteLine(point.X);
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T : IPoint
{
  readonly T point;  // this could be a struct
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX) // assignment has been removed
  {
    Console.WriteLine(point.X);
  }
}
</pre>
<p>or</p>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T : class, IPoint
{
  readonly T point;  // this can only be a class
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX)
  {
    point.X = newX;  // this assignment is guaranteed to work
    Console.WriteLine(point.X);
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2955</key>
    <type>BUG</type>
    <name>Generic parameters not constrained to reference types should not be compared to "null"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a
<code>struct</code>, could also be passed. In such cases, comparing the type parameter to <code>null</code> would always be false, because a
<code>struct</code> can be empty, but never <code>null</code>. If a value type is truly what's expected, then the comparison should use
<code>default()</code>. If it's not, then constraints should be added so that no value type can be passed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private bool IsDefault&lt;T&gt;(T value)
{
  if (value == null) // Noncompliant
  {
    // ...
  }
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
private bool IsDefault&lt;T&gt;(T value)
{
  if(object.Equals(value, default(T)))
  {
    // ...
  }
  // ...
}
</pre>
<p>or</p>
<pre>
private bool IsDefault&lt;T&gt;(T value) where T : class
{
  if (value == null)
  {
    // ...
  }
  // ...
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3246</key>
    <type>CODE_SMELL</type>
    <name>Generic type parameters should be co/contravariant when possible</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the <code>out</code> and
<code>in</code> modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively.</p>
<p>The <code>out</code> keyword can be used when the type parameter is used only as a return type in the interface or delegate. Doing so makes the
parameter covariant, and allows interface and delegate instances created with a sub-type to be used as instances created with a base type. The most
notable example of this is <code>IEnumerable&lt;out T&gt;</code>, which allows the assignment of an <code>IEnumerable&lt;string&gt;</code> instance to
an <code>IEnumerable&lt;object&gt;</code> variable, for instance.</p>
<p>The <code>in</code> keyword can be used when the type parameter is used only as a method parameter in the interface or a parameter in the delegate.
Doing so makes the parameter contravariant, and allows interface and delegate instances created with a base type to be used as instances created with
a sub-type. I.e. this is the inversion of covariance. The most notable example of this is the <code>Action&lt;in T&gt;</code> delegate, which allows
the assignment of an <code>Action&lt;object&gt;</code> instance to a <code>Action&lt;string&gt;</code> variable, for instance.</p>
<h2>Noncompliant Code Example</h2>
<pre>
interface IConsumer&lt;T&gt;  // Noncompliant
{
    bool Eat(T fruit);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
interface IConsumer&lt;in T&gt;
{
    bool Eat(T fruit);
}
</pre>

]]></description>
    <tag>api-design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4018</key>
    <type>CODE_SMELL</type>
    <name>Generic methods should provide type parameters</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The best way to determine the type of a generic method is by inference based on the type of argument that is passed to the method. This is not
possible when a parameter type is missing from the argument list.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
  public class Foo
  {
    public void MyMethod&lt;T&gt;()  // Noncompliant
    {
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
  public class Foo
  {
    public void MyMethod&lt;T&gt;(T param)
    {
    }
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2326</key>
    <type>CODE_SMELL</type>
    <name>Unused type parameters should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Type parameters that aren't used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type
parameters should be removed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MoreMath&lt;T&gt;   // Noncompliant; &lt;T&gt; is ignored
{
  public int Add&lt;T&gt;(int a, int b) // Noncompliant; &lt;T&gt; is ignored
  {
    return a + b;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MoreMath
{
  public int Add (int a, int b)
  {
    return a + b;
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3249</key>
    <type>BUG</type>
    <name>Classes directly extending "object" should not call "base" in "GetHashCode" or "Equals"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Making a <code>base</code> call in an overriding method is generally a good idea, but not in <code>GetHashCode</code> and <code>Equals</code> for
classes that directly extend <code>object</code> because those methods are based on the object reference. Meaning that no two <code>objects</code>
that use those <code>base</code> methods will ever be equal or have the same hash.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode() ^ base.GetHashCode(); //Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode();
  }
}
</pre>
<h2>Exceptions</h2>
<p>This rule doesn't report on guard conditions checking for reference equality.</p>
<pre>
public class Point
{
  public override bool Equals(object obj)
  {
    if (base.Equals(obj)) // Compliant, although it could be replaced with object.ReferenceEquals(obj, this), which is clearer
    {
      return true;
    }
    ...
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2328</key>
    <type>BUG</type>
    <name>"GetHashCode" should not reference mutable fields</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>GetHashCode</code> is used to file an object in a <code>Dictionary</code> or <code>Hashtable</code>. If <code>GetHashCode</code> uses
non-<code>readonly</code> fields and those fields change after the object is stored, the object immediately becomes mis-filed in the
<code>Hashtable</code>. Any subsequent test to see if the object is in the <code>Hashtable</code> will return a false negative.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Person
{
  public int age;
  public string name;

  public override int GetHashCode()
  {
    int hash = 12;
    hash += this.age.GetHashCode(); // Noncompliant
    hash += this.name.GetHashCode(); // Noncompliant
    return hash;
  }
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Person
{
  public readonly DateTime birthday;
  public string name;

  public override int GetHashCode()
  {
    int hash = 12;
    hash += this.birthday.GetHashCode();
    return hash;
  }
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2219</key>
    <type>CODE_SMELL</type>
    <name>Runtime type checking should be simplified</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>To check the type of an object there are several options:</p>
<ul>
  <li> <code>expr is SomeType</code> or <code>expr.GetType() == typeof(SomeType)</code> if the type is known at compile time, </li>
  <li> <code>typeInstance.IsInstanceOfType(expr)</code> if the type is calculated during runtime. </li>
</ul>
<p>If runtime calculated <code>Type</code>s need to be compared:</p>
<ul>
  <li> <code>typeInstance1.IsAssignableFrom(typeInstance2)</code>. </li>
</ul>
<p>Depending on whether the type is returned by a <code>GetType()</code> or <code>typeof()</code> call, the <code>IsAssignableFrom()</code> and
<code>IsInstanceOfType()</code> might be simplified. Similarly, if the type is <code>sealed</code>, the type comparison with <code>==</code> can be
converted to an <code>is</code> call. Simplifying the calls also make <code>null</code> checking unnecessary because both <code>is</code> and
<code>IsInstanceOfType</code> performs it already.</p>
<p>Finally, utilizing the most concise language constructs for type checking makes the code more readable, so</p>
<ul>
  <li> <code>expr as T != null</code> checks should be simplified to <code>expr is T</code>, and </li>
  <li> <code>expr is T</code> should be converted to <code>expr != null</code>, when <code>expr</code> is of type <code>T</code>. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
class Fruit { }
sealed class Apple : Fruit { }

class Program
{
  static void Main()
  {
    var apple = new Apple();
    var b = apple != null &amp;&amp; apple.GetType() == typeof (Apple); // Noncompliant
    b = typeof(Apple).IsInstanceOfType(apple); // Noncompliant
    if (apple != null)
    {
      b = typeof(Apple).IsAssignableFrom(apple.GetType()); // Noncompliant
    }
    var appleType = typeof (Apple);
    if (apple != null)
    {
      b = appleType.IsAssignableFrom(apple.GetType()); // Noncompliant
    }

    Fruit f = apple;
    if (f as Apple != null) // Noncompliant
    {
    }
    if (apple is Apple) // Noncompliant
    {
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Fruit { }
sealed class Apple : Fruit { }

class Program
{
  static void Main()
  {
    var apple = new Apple();
    var b = apple is Apple;
    b = apple is Apple;
    b = apple is Apple;
    var appleType = typeof(Apple);
    b = appleType.IsInstanceOfType(apple);

    Fruit f = apple;
    if (f is Apple)
    {
    }
    if (apple != null)
    {
    }
  }
}
</pre>
<h2>Exceptions</h2>
<p>Calling <code>GetType</code> on an object of <code>Nullable&lt;T&gt;</code> type returns the underlying generic type parameter <code>T</code>, thus
a comparison with <code>typeof(Nullable&lt;T&gt;)</code> can't be simplified to use the <code>is</code> operator, which doesn't make difference
between <code>T</code> and <code>T?</code>.</p>
<pre>
int? i = 42;
bool condition = i.GetType() == typeof(int?); // false;
condition = i is int?; // true
</pre>
<p>No issue is reported on <code>expr is T</code> expressions if either operand of the <code>is</code> operator is a value type. In that case CS0183
or CS0184 reports.</p>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S907</key>
    <type>CODE_SMELL</type>
    <name>"goto" statement should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>goto</code> is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such
as <code>if</code>, <code>for</code>, <code>while</code>, <code>continue</code> or <code>break</code> should be used instead.</p>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 14.4 - The goto statement shall not be used. </li>
  <li> MISRA C:2012, 15.1 - The goto statement should not be used </li>
</ul>

]]></description>
    <tag>brain-overload</tag>
    <tag>misra</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3397</key>
    <type>BUG</type>
    <name>"base.Equals" should not be used to check for reference equality in "Equals" if "base" is not "object"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>object.Equals()</code> overrides can be optimized by checking first for reference equality between <code>this</code> and the parameter. This
check can be implemented by calling <code>object.ReferenceEquals()</code> or <code>base.Equals()</code>, where <code>base</code> is
<code>object</code>. However, using <code>base.Equals()</code> is a maintenance hazard because while it works if you extend <code>Object</code>
directly, if you introduce a new base class that overrides <code>Equals</code>, it suddenly stops working.</p>
<p>This rule raises an issue if <code>base.Equals()</code> is used but <code>base</code> is not <code>object</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (base.Equals(other)) // Okay; base is object
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (base.Equals(other))  // Noncompliant
    {
      return true;
    }

    return this.derivedField == ((Derived)other).derivedField;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))
    {
      return true;
    }

    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1313</key>
    <type>VULNERABILITY</type>
    <name>IP addresses should not be hardcoded</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Hardcoding an IP address into source code is a bad idea for several reasons:</p>
<ul>
  <li> a recompile is required if the address changes </li>
  <li> it forces the same address to be used in every environment (dev, sys, qa, prod) </li>
  <li> it places the responsibility of setting the value to use in production on the shoulders of the developer </li>
  <li> it allows attackers to decompile the code and thereby discover a potentially sensitive address </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
var ip = "127.0.0.1";
var address = IPAddress.Parse(ip);
</pre>
<h2>Compliant Solution</h2>
<pre>
var ip = ConfigurationManager.AppSettings["myapplication.ip"];
var address = IPAddress.Parse(ip);
</pre>
<h2>Exceptions</h2>
<p>Although "::" is a valid IPv6 address, the rule doesn't report on it. </p>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/qQCHAQ">CERT, MSC03-J.</a> - Never hard code sensitive information </li>
</ul>

]]></description>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S126</key>
    <type>CODE_SMELL</type>
    <name>"if ... else if" constructs should end with "else" clauses</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>This rule applies whenever an <code>if</code> statement is followed by one or more <code>else if</code> statements; the final <code>else if</code>
should be followed by an <code>else</code> statement.</p>
<p>The requirement for a final <code>else</code> statement is defensive programming.</p>
<p>The <code>else</code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is
consistent with the requirement to have a final <code>default</code> clause in a <code>switch</code> statement.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (x == 0)
{
  doSomething();
} else if (x == 1)
{
  doSomethingElse();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (x == 0)
{
  doSomething();
} else if (x == 1)
{
  doSomethingElse();
} else
{
  throw new IllegalStateException();
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. </li>
  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. </li>
  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/YgE">CERT, MSC01-C.</a> - Strive for logical completeness </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/JoIyAQ">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/PQHRAw">CERT, MSC57-J.</a> - Strive for logical completeness </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1066</key>
    <type>CODE_SMELL</type>
    <name>Collapsible "if" statements should be merged</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Merging collapsible <code>if</code> statements increases the code's readability.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (condition1)
{
  if (condition2)
  {
    ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (condition1 &amp;&amp; condition2)
{
  ...
}
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1145</key>
    <type>BUG</type>
    <name>Useless "if(true) {...}" and "if(false){...}" blocks should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>if</code> statements with conditions that are always false have the effect of making blocks of code non-functional. <code>if</code>
statements with conditions that are always true are completely redundant, and make the code less readable.</p>
<p>There are three possible causes for the presence of such code: </p>
<ul>
  <li> An if statement was changed during debugging and that debug code has been committed. </li>
  <li> Some value was left unset. </li>
  <li> Some logic is not doing what the programmer thought it did. </li>
</ul>
<p>In any of these cases, unconditional <code>if</code> statements should be removed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (true)
{
  DoSomething();
}
...
if (false)
{
  DoSomethingElse();
}

if (2 &lt; 3 ) { ... }  // Noncompliant; always false

int i = 0;
int j = 0;
// ...
j = Foo();

if (j &gt; 0 &amp;&amp; i &gt; 0) { ... }  // Noncompliant; always false - i never set after initialization

bool b = true;
//...
if (b || !b) { ... }  // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
DoSomething();
...
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/489.html">MITRE, CWE-489</a> - Leftover Debug Code </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/570.html">MITRE, CWE-570</a> - Expression is Always False </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/571.html">MITRE, CWE-571</a> - Expression is Always True </li>
  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>
  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>
</ul>
<h2>Deprecated</h2>
<p>This rule is deprecated; use {rule:csharpsquid:S2583} instead.</p>

]]></description>
    <tag>cwe</tag>
    <tag>misra</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3881</key>
    <type>CODE_SMELL</type>
    <name>"IDisposable" should be implemented correctly</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>IDisposable</code> interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource
leaks or more severe bugs.</p>
<p>This rule raises an issue when the recommended dispose pattern, as defined by Microsoft, is not adhered to. See the <strong>Compliant
Solution</strong> section for examples.</p>
<p>Satisfying the rule's conditions will enable potential derived classes to correctly dispose the members of your class:</p>
<ul>
  <li> <code>sealed</code> classes are not checked. </li>
  <li> If a base class implements <code>IDisposable</code> your class should not have <code>IDisposable</code> in the list of its interfaces. In such
  cases it is recommended to override the base class's <code>protected virtual void Dispose(bool)</code> method or its equivalent. </li>
  <li> The class should not implement <code>IDisposable</code> explicitly, e.g. the <code>Dispose()</code> method should be public. </li>
  <li> The class should contain <code>protected virtual void Dispose(bool)</code> method. This method allows the derived classes to correctly dispose
  the resources of this class. </li>
  <li> The content of the <code>Dispose()</code> method should be a single invocation of <code>Dispose(true)</code>. </li>
  <li> If the class has a finalizer, i.e. a destructor, the only code in its body should be a single invocation of <code>Dispose(false)</code>. </li>
  <li> If the class has a finalizer, an additional call to <code>GC.SuppressFinalize(this)</code> is required in the <code>Dispose()</code> method.
  </li>
  <li> If the class inherits from a class that implements <code>IDisposable</code> it must call the <code>Dispose</code>, or
  <code>Dispose(bool)</code> method of the base class from within its own implementation of <code>Dispose</code> or <code>Dispose(bool)</code>,
  respectively. This ensures that all resources from the base class are properly released. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo1 : IDisposable // Noncompliant - provide protected overridable implementation of Dispose(bool) on Foo or mark the type as sealed.
{
    public void Dispose() // Noncompliant - should contain only a call to Dispose(true) and then GC.SuppressFinalize(this)
    {
        // Cleanup
    }
}

public class Foo2 : IDisposable
{
    void IDisposable.Dispose() // Noncompliant - Dispose() should be public
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    public virtual void Dispose() // Noncompliant - Dispose() should be sealed
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}

public class Foo3 : IDisposable
{
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        // Cleanup
    }

    ~Foo3() // Noncompliant - Modify Foo.~Foo() so that it calls Dispose(false) and then returns.
    {
        // Cleanup
    }
}{code}
</pre>
<h2>Compliant Solution</h2>
<pre>
// Sealed class
public sealed class Foo1 : IDisposable
{
    public void Dispose()
    {
        // Cleanup
    }
}

// Simple implementation
public class Foo2 : IDisposable
{
    public void Dispose()
    {
        Dispose(true);
    }

    protected virtual void Dispose(bool disposing)
    {
        // Cleanup
    }
}

// Implementation with a finalizer
public class Foo3 : IDisposable
{
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        // Cleanup
    }

    ~Foo3()
    {
        Dispose(false);
    }
}

// Base disposable class
public class Foo4 : DisposableBase
{
    protected override void Dispose(bool disposing)
    {
        // Cleanup
        // Do not forget to call base
        base.Dispose(disposing);
    }
}
</pre>
<h2>See</h2>
<p>Refer to </p>
<ul>
  <li> <a href="https://msdn.microsoft.com/en-us/library/498928w2.aspx">MSDN</a> for complete documentation on the dispose pattern. </li>
  <li> <a href="http://blog.stephencleary.com/2009/08/how-to-implement-idisposable-and.html">Stephen Cleary</a> for excellent Q&amp;A about
  IDisposable </li>
  <li> <a href="http://pragmateek.com/c-scope-your-global-state-changes-with-idisposable-and-the-using-statement/">Pragma Geek</a> for additional
  usages of IDisposable, beyond releasing resources. </li>
</ul>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3925</key>
    <type>CODE_SMELL</type>
    <name>"ISerializable" should be implemented correctly</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>ISerializable</code> interface is the mechanism to control the type serialization process. If not implemented correctly this could result
in an invalid serialization and hard to detect bugs.</p>
<p>This rules raises an issue on types that implement <code>ISerializable</code> without following the serialization pattern recommended by
Microsoft.</p>
<p>Specifically this rule checks for these problems:</p>
<ul>
  <li> The <code>System.SerializableAttribute</code> attribute is missing. </li>
  <li> Non-serializable fields are not marked with the <code>System.NonSerializedAttribute</code> attribute. </li>
  <li> There is no serialization constructor. </li>
  <li> An unsealed type has a serialization constructor that is not <code>protected</code>. </li>
  <li> A sealed type has a serialization constructor that is not <code>private</code>. </li>
  <li> An unsealed type has a <code>ISerializable.GetObjectData</code> that is not both <code>public</code> and <code>virtual</code>. </li>
  <li> A derived type has a serialization constructor that does not call the <code>base</code> constructor. </li>
  <li> A derived type has a <code>ISerializable.GetObjectData</code> method that does not call the <code>base</code> method. </li>
  <li> A derived type has serializable fields but the <code>ISerializable.GetObjectData</code> method is not overridden. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo : ISerializable // Noncompliant the [Serializable] attribute is missing
{
}
</pre>
<p>or</p>
<pre>
public class Bar
{
}

[Serializable]
public class Foo : ISerializable // Noncompliant the serialization constructor is missing
{
    private readonly Bar bar; // Noncompliant the field is not marked with [NonSerialized]
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Bar
{
}

[Serializable]
public class Foo : ISerializable
{
    [NonSerialized]
    private readonly Bar bar;

    public Foo()
    {
        // ...
    }

    protected Foo(SerializationInfo info, StreamingContext context)
    {
        // ...
    }

    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        // ...
    }
}

[Serializable]
public sealed class SubFoo : Foo
{
    private int val;

    public SubFoo()
    {
        // ...
    }

    private SubFoo(SerializationInfo info, StreamingContext context)
        : base(info, context)
    {
        // ...
    }

    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        base.GetObjectData(info, context);
        // ...
    }
}
</pre>
<h2>Exceptions</h2>
<ul>
  <li> Classes in test projects are not checked. </li>
</ul>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2692</key>
    <type>CODE_SMELL</type>
    <name>"IndexOf" checks should not be for positive numbers</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Most checks against an <code>IndexOf</code> value compare it with -1 because 0 is a valid index. Any checks which look for values
<code>&gt;0</code> ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a value in a <code>string</code>,
<code>List</code>, or an array, consider using the <code>Contains</code> method instead.</p>
<p>This rule raises an issue when an <code>IndexOf</code> value retrieved from a <code>string</code>, <code>List</code>, or array is tested against
<code>&gt;0</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
string color = "blue";
string name = "ishmael";

List&lt;string&gt; strings = new List&lt;string&gt;();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) &gt; 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ish") &gt; 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ae") &gt; 0) // Noncompliant
{
  // ...
}
if (Array.IndexOf(stringArray, color) &gt; 0) // Noncompliant
{
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
string color = "blue";
string name = "ishmael";

List&lt;string&gt; strings = new List&lt;string&gt; ();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) &gt; -1)
{
  // ...
}
if (name.IndexOf("ish") &gt;= 0)
{
  // ...
}
if (name.Contains("ae"))
{
  // ...
}
if (Array.IndexOf(stringArray, color) &gt;= 0)
{
  // ...
}
</pre>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2190</key>
    <type>BUG</type>
    <name>Recursion should not be infinite</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods invoke each other,
or when <code>goto</code>s are used to move between two segments of code. It can be a useful tool, but unless the method includes a provision to break
out of the recursion and <code>return</code>, the recursion will continue until the stack overflows and the program crashes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int Pow(int num, int exponent)   // Noncompliant; no condition under which pow isn't re-called
{
  num = num * Pow(num, exponent-1);
  return num;  // this is never reached
}

void InternalRecursion(int i)
{
  start:
    goto end;
  end:
    goto start; // Noncompliant; there's no way to break out of this method
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int Pow(int num, int exponent)
{
  if (exponent &gt; 1) // recursion now conditional and stop-able
  {
    num = num * Pow(num, exponent-1);
  }
  return num;
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3444</key>
    <type>CODE_SMELL</type>
    <name>Interfaces should not simply inherit from base interfaces with colliding members</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived
interface will result in the compiler error <code>CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'</code>.</p>
<p>So instead, every caller will be forced to cast instances of the derived interface to one or the other of its base interfaces to resolve the
ambiguity and be able to access the member. Instead, it is better to resolve the ambiguity in the definition of the derived interface either by:</p>
<ul>
  <li> renaming the member in one of the base interfaces to remove the collision </li>
  <li> also defining that member in the derived interface. Use this only if all copies of the member are meant to hold the same value. </li>
</ul>
<p> </p>
<h2>Noncompliant Code Example</h2>
<pre>
public interface IBase1
{
  string SomeProperty { get; set; }
}

public interface IBase2
{
  string SomeProperty { get; set; }
}

public interface IDerived : IBase1, IBase2 // Noncompliant, accessing IDerived.SomeProperty is ambiguous
{
}

public class MyClass : IDerived
{
  // Implements both IBase1.SomeProperty and IBase2.SomeProperty
  public string SomeProperty { get; set; } = "Hello";

  public static void Main()
  {
    MyClass myClass = new MyClass();
    Console.WriteLine(myClass.SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IDerived)myClass).SomeProperty); // Error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public interface IDerived : IBase1, IBase2
{
  new string SomeProperty { get; set; }
}

public class MyClass : IDerived
{
  // Implements IBase1.SomeProperty, IBase2.SomeProperty and IDerived.SomeProperty
  public string SomeProperty { get; set; } = "Hello";

  public static void Main()
  {
    MyClass myClass = new MyClass();
    Console.WriteLine(myClass.SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IDerived)myClass).SomeProperty); // Writes "Hello" as expected
  }
}
</pre>
<p>or</p>
<pre>
public interface IBase1
{
  string SomePropertyOne { get; set; }
}

public interface IBase2
{
  string SomePropertyTwo { get; set; }
}

public interface IDerived : IBase1, IBase2
{
}
</pre>

]]></description>
    <tag>design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3963</key>
    <type>CODE_SMELL</type>
    <name>"static" fields should be initialized inline</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When a <code>static</code> constructor serves no other purpose that initializing <code>static</code> fields, it comes with an unnecessary
performance cost because the compiler generates a check before each <code>static</code> method or instance constructor invocation.</p>
<p>Instead, inline initialization is highly recommended.</p>
<h2>Noncompliant Code Example</h2>
<pre>
namespace myLib
{
  public class Foo
  {
    static int i;
    static string s;

    static Foo() // Noncompliant
    {
      i = 3;
      ResourceManager sm =  new ResourceManager("strings", Assembly.GetExecutingAssembly());
      s = sm.GetString("mystring");
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
namespace myLib
{
  public class Foo
  {
    static int i =3;
    static string s = InitString();

    static string InitString()
    {
      ResourceManager sm = new ResourceManager("strings", Assembly.GetExecutingAssembly());
      return sm.GetString("mystring");
    }
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2278</key>
    <type>VULNERABILITY</type>
    <name>Neither DES (Data Encryption Standard) nor DESede (3DES) should be used</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>According to the US National Institute of Standards and Technology (NIST), the Data Encryption Standard (DES) is no longer considered secure:</p>
<blockquote>
  <p>Adopted in 1977 for federal agencies to use in protecting sensitive, unclassified information, the DES is being withdrawn because it no longer
  provides the security that is needed to protect federal government information.</p>
  <p>Federal agencies are encouraged to use the Advanced Encryption Standard, a faster and stronger algorithm approved as FIPS 197 in 2001.</p>
</blockquote>
<p>For similar reasons, RC2 should also be avoided.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using (var tripleDES = new TripleDESCryptoServiceProvider()) //Noncompliant
{
  //...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using (var aes = new AesCryptoServiceProvider())
{
  //...
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/326.html">MITRE CWE-326</a> - Inadequate Encryption Strength </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/327.html">MITRE CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm </li>
  <li> <a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/VwAZAg">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>
  <li> Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#DES_USAGE">DES / DESede Unsafe</a> </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>cert</tag>
    <tag>owasp-a6</tag>
    <tag>sans-top25-porous</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2070</key>
    <type>VULNERABILITY</type>
    <name>SHA-1 and Message-Digest hash algorithms should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to create hash collisions with them. That is,
it takes too little computational effort to come up with a different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash
value gives an attacker the same access as if he had the originally-hashed value. This applies as well to the other Message-Digest algorithms: MD2,
MD4, MD6.</p>
<p>This rule tracks usage of the <code>System.Security.Cryptography.CryptoConfig.CreateFromName()</code>, and
<code>System.Security.Cryptography.HashAlgorithm.Create()</code> methods to instantiate MD5 or SHA-1 algorithms, and of derived class instances of
<code>System.Security.Cryptography.SHA1</code> and <code>System.Security.Cryptography.MD5</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
var hashProvider1 = new MD5CryptoServiceProvider(); //Noncompliant
var hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName("MD5"); //Noncompliant
var hashProvider3 = new SHA1Managed(); //Noncompliant
var hashProvider4 = HashAlgorithm.Create("SHA1"); //Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
var hashProvider1 = new SHA256Managed();
var hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName("SHA256Managed");
var hashProvider3 = HashAlgorithm.Create("SHA256Managed");
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/328">MITRE, CWE-328</a> - Reversible One-Way Hash </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/327">MITRE, CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm </li>
  <li> <a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure
  </li>
  <li> <a href="http://www.sans.org/top25-software-errors/">SANS Top 25</a> - Porous Defenses </li>
  <li> Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#WEAK_MESSAGE_DIGEST">MessageDigest Is Weak</a> </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>owasp-a6</tag>
    <tag>sans-top25-porous</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4023</key>
    <type>CODE_SMELL</type>
    <name>Interfaces should not be empty</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Empty interfaces are usually used as a marker or a way to identify groups of types. The preferred way to achieve this is to use custom
attributes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
   public interface MyInterface // Noncompliant
   {
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
   public interface MyInterface
   {
      void Foo();
   }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1944</key>
    <type>BUG</type>
    <name>Inappropriate casts should not be made</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Inappropriate casts are issues that will lead to unexpected behavior or runtime errors, such as <code>InvalidCastException</code>s. The compiler
will catch bad casts from one class to another, but not bad casts to interfaces. Nor will it catch nullable values that are known to be null but that
are cast to their underlying value types anyway.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public interface IMyInterface
{ /* ... */ }

public class Implementer : IMyInterface
{ /* ... */ }

public class MyClass
{ /* ... */ }

public static class Program
{
  public static void Main()
  {
    var myclass = new MyClass();
    var x = (IMyInterface) myclass; // Noncompliant, InvalidCastException is being thrown
    var b = myclass is IMyInterface; // Noncompliant, always false

    int? i = null;
    var ii = (int)i; // Noncompliant, InvalidOperationException is being thrown
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public interface IMyInterface
{ /* ... */ }

public class Implementer : IMyInterface
{ /* ... */ }

public class MyClass
{ /* ... */ }

public static class Program
{
  public static void Main()
  {
    var myclass = new MyClass();
    var x = myclass as IMyInterface; // Compliant, but will always be null
    var b = false;

    int? i = null;
    if (i.HasValue)
    {
      var ii = (int)i;
    }
  }
}
</pre>
<h2>Exceptions</h2>
<p>No issue is reported if the interface has no implementing class in the assembly.</p>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 11.4 - A cast should not be performed between a pointer to object type and an integral type. </li>
  <li> MISRA C++:2008, 5-2-3 - Casts to a base class from a derived class should not be performed on polymorphic types. </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/tgAV">CERT, EXP36-C.</a> - Do not cast pointers into more strictly aligned pointer
  types </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/588.html">MITRE, CWE-588</a> - Attempt to Access Child of a Non-structure Pointer </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/704.html">MITRE, CWE-704</a> - Incorrect Type Conversion or Cast </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3220</key>
    <type>CODE_SMELL</type>
    <name>Method calls should not resolve ambiguously to overloads with "params"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The rules for method resolution are complex and perhaps not properly understood by all coders. The <code>params</code> keyword can make method
declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods.</p>
<p>This rule raises an issue when an invocation resolves to a method declaration with <code>params</code>, but could also resolve to another
non-<code>params</code> method too.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  private void Format(string a, params object[] b) { }

  private void Format(object a, object b, object c) { }
}

// ...
MyClass myClass = new MyClass();

myClass.Format("", null, null); //Noncompliant, resolves to the first Format with params, but was that intended?
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1309</key>
    <type>CODE_SMELL</type>
    <name>Track uses of in-source issue suppressions</name>
    <severity>INFO</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>This rule allows you to track the usage of the <code>SuppressMessage</code> attributes and <code>#pragma warning disable</code> mechanism.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[SuppressMessage("", "S100")]
...

#pragma warning disable S100
...
#pragma warning restore S100
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S103</key>
    <type>CODE_SMELL</type>
    <name>Lines should not be too long</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</p>

]]></description>
    <tag>convention</tag>
    <param>
      <key>maximumLineLength</key>
      <description><![CDATA[The maximum authorized line length.]]></description>
      <type>INTEGER</type>
      <defaultValue>200</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S818</key>
    <type>CODE_SMELL</type>
    <name>Literal suffixes should be upper case</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using upper case literal suffixes removes the potential ambiguity between "1" (digit 1) and "l" (letter el) for declaring literals.</p>
<h2>Noncompliant Code Example</h2>
<pre>
const long b = 0l;      // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
const long b = 0L;
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case </li>
  <li> MISRA C:2012, 7.3 - The lowercase character "l" shall not be used in a literal suffix </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/koAtAQ">CERT DCL16-C.</a> - Use "L," not "l," to indicate a long value </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/n4AtAQ">CERT DCL16-CPP.</a> - Use "L," not "l," to indicate a long value </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/hYClBg">CERT, DCL50-J.</a> - Use visually distinct identifiers </li>
</ul>

]]></description>
    <tag>convention</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2551</key>
    <type>BUG</type>
    <name>Types and "this" should not be used for locking</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Locking on the current object instance (i.e. <code>this</code>), or on a <code>Type</code> object increases the chance of deadlocks because any
other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose. </p>
<p>Instead, a new, private <code>object</code> should be created and used for the lock.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void MyLockingMethod()
{
  lock (this) // Noncompliant
  {
    // ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
object lockObj = new object();

public void MyLockingMethod()
{
  lock (lockObj)
  {
    // ...
  }
}
</pre>

]]></description>
    <tag>multi-threading</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2184</key>
    <type>BUG</type>
    <name>Results of integer division should not be assigned to floating point variables</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When division is performed on <code>int</code>s, the result will always be an <code>int</code>. You can assign that result to a
<code>double</code>, <code>float</code> or <code>decimal</code> with automatic type conversion, but having started as an <code>int</code>, the result
will likely not be what you expect. If the result of <code>int</code> division is assigned to a floating-point variable, precision will have been lost
before the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.</p>
<h2>Noncompliant Code Example</h2>
<pre>
static void Main()
{
  decimal dec = 3/2; // Noncompliant
  Method(3/2); // Noncompliant
}

static void Method(float f) { }
</pre>
<h2>Compliant Solution</h2>
<pre>
static void Main()
{
  decimal dec = (decimal)3/2;
  Method(3.0F/2);
}

static void Method(float f) { }
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 5-0-8 - An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue
  expression. </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/190">MITRE, CWE-190</a> - Integer Overflow or Wraparound </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/woIyAQ">CERT, NUM50-J.</a> - Convert integers to floating point for floating-point
  operations </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/AxE">CERT, INT18-C.</a> - Evaluate integer expressions in a larger size before
  comparing or assigning to that size </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/1IAyAQ">CERT, INT18-CPP.</a> - Evaluate integer expressions in a larger size before
  comparing or assigning to that size </li>
  <li> <a href="http://www.sans.org/top25-software-errors/">SANS Top 25</a> - Risky Resource Management </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>overflow</tag>
    <tag>sans-top25-risky</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3904</key>
    <type>CODE_SMELL</type>
    <name>Assemblies should have version information</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>If no <code>AssemblyVersionAttribute</code> is provided, the same default version will be used for every build. Since the version number is used by
The .NET Framework to uniquely identify an assembly this can lead to broken dependencies.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;
using System.Reflection;

[assembly: AssemblyTitle("MyAssembly")] // Noncompliant

namespace MyLibrary
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;
using System.Reflection;

[assembly: AssemblyTitle("MyAssembly")]
[assembly: AssemblyVersionAttribute("1.2.125.0")]

namespace MyLibrary
{
}
</pre>
<h2>See</h2>
<p><a href="https://msdn.microsoft.com/en-us/library/51ket42z.aspx">Assembly Versioning (MSDN)</a></p>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3990</key>
    <type>CODE_SMELL</type>
    <name>Assemblies should be marked as CLS compliant</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Assemblies should conform with the Common Language Specification (CLS) in order to be usable across programming languages. To be compliant an
assembly has to indicate it with <code>System.CLSCompliantAttribute</code>.</p>
<h2>Compliant Solution</h2>
<pre>
using System;

[assembly:CLSCompliant(true)]
namespace MyLibrary
{
}
</pre>

]]></description>
    <tag>api-design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3992</key>
    <type>CODE_SMELL</type>
    <name>Assemblies should explicitly specify COM visibility</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Assemblies should explicitly indicate whether they are meant to be COM visible or not. If the <code>ComVisibleAttribute</code> is not present, the
default is to make the content of the assembly visible to COM clients.</p>
<p>Note that COM visibility can be overridden for individual types and members.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary  // Noncompliant
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
namespace MyLibrary
{
}
</pre>

]]></description>
    <tag>api-design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4026</key>
    <type>CODE_SMELL</type>
    <name>Assemblies should be marked with "NeutralResourcesLanguageAttribute"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>It is important to inform the <code>ResourceManager</code> of the language used to display the resources of the neutral culture for an assembly.
This improves lookup performance for the first resource loaded. </p>
<p>This rule raises an issue when an assembly contains a <code>ResX</code>-based resource but does not have the
<code>System.Resources.NeutralResourcesLanguageAttribute</code> applied to it.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

public class MyClass // Noncompliant
{
   public static void Main()
   {
      string[] cultures = { "de-DE", "en-us", "fr-FR" };
      Random rnd = new Random();
      int index = rnd.Next(0, cultures.Length);
      Thread.CurrentThread.CurrentUICulture = CultureInfo.CreateSpecificCulture(cultures[index]);

      ResourceManager rm = new ResourceManager("MyResources" ,
                                               typeof(MyClass).Assembly);
      string greeting = rm.GetString("Greeting");

      Console.Write("Enter your name: ");
      string name = Console.ReadLine();
      Console.WriteLine("{0} {1}!", greeting, name);
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

[assembly:NeutralResourcesLanguageAttribute("en")]
public class MyClass
{
   public static void Main()
   {
      string[] cultures = { "de-DE", "en-us", "fr-FR" };
      Random rnd = new Random();
      int index = rnd.Next(0, cultures.Length);
      Thread.CurrentThread.CurrentUICulture = CultureInfo.CreateSpecificCulture(cultures[index]);

      ResourceManager rm = new ResourceManager("MyResources" ,
                                               typeof(MyClass).Assembly);
      string greeting = rm.GetString("Greeting");

      Console.Write("Enter your name: ");
      string name = Console.ReadLine();
      Console.WriteLine("{0} {1}!", greeting, name);
   }
}
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3052</key>
    <type>CODE_SMELL</type>
    <name>Members should not be initialized to default values</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization
values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it's
considered poor style to do so.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class X
{
  public int field = 0; // Noncompliant
  public object o = null; // Noncompliant
  public object MyProperty { get; set; } = null; // Noncompliant
  public event EventHandler MyEvent = null;  // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class X
{
  public int field;
  public object o;
  public object MyProperty { get; set; }
  public event EventHandler MyEvent;
}
</pre>
<h2>Exceptions</h2>
<p><code>const</code> fields are ignored.</p>

]]></description>
    <tag>convention</tag>
    <tag>finding</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3604</key>
    <type>CODE_SMELL</type>
    <name>Member initializer values should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same
time is redundant; the inline initialization will be overridden.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Person
{
  int age = 42; // Noncompliant
  public Person(int age)
  {
    this.age = age;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Person
{
  int age;
  public Person(int age)
  {
    this.age = age;
  }
}
</pre>
<h2>Exceptions</h2>
<p>This rule doesn't report an issue if not all constructors initialize the field. If the field is initialized inline to its default value, then
{rule:csharpsquid:S3052} already reports an issue on the initialization. </p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1185</key>
    <type>CODE_SMELL</type>
    <name>Overriding members should do more than simply call the same member in the base class</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time
this is justified is in <code>sealed</code> overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides
of <code>Equals</code> and <code>GetHashCode</code>.</p>
<p>NOTE: In some cases it might be dangerous to add or remove empty overrides, as they might be breaking changes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public override void Method() // Noncompliant
{
  base.Method();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public override void Method()
{
  //do something else
}
</pre>
<h2>Exceptions</h2>
<p>If there is an attribute in any level of the overriding chain, then the overridden member is ignored.</p>
<pre>
public class Base
{
  [Required]
  public virtual string Name { get; set; }
}

public class Derived : Base
{
  public override string Name
  {
    get
    {
      return base.Name;
    }
    set
    {
      base.Name = value;
    }
  }
}
</pre>
<p>If there is a documentation comment on the overriding method, it will be ignored:</p>
<pre>
public class Foo : Bar
{
    /// &lt;summary&gt;
    /// Keep this method for backwards compatibility.
    /// &lt;/summary&gt;
    public override void DoSomething()
    {
        base.DoSomething();
    }
}
</pre>

]]></description>
    <tag>redundant</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3218</key>
    <type>CODE_SMELL</type>
    <name>Inner class members should not shadow outer class "static" or type members</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>It's possible to name the members of an inner class the same as the <code>static</code> members of its enclosing class - possible, but a bad idea.
That's because maintainers may be confused about which members are being used where. Instead the inner class' members should be renamed and all the
references updated.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Outer
{
  public static int A;

  public class Inner
  {
    public int A; //Noncompliant
    public int MyProp
    {
      get { return A; }  // Returns inner A. Was that intended?
    }
  }
}
</pre>
<p>After a rename</p>
<pre>
class Outer
{
  public static int A;

  public class Inner
  {
    public int B;
    public int MyProp
    {
      get { return A; }  // Still compiles and runs but functionality has changed
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Outer
{
  public static int A;

  public class Inner
  {
    public int InnerA;
    public int MyProp
    {
      get { return InnerA; }
    }
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/2ADEAw">CERT, DCL51-J.</a> - Do not shadow or obscure identifiers in subscopes </li>
</ul>

]]></description>
    <tag>design</tag>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2325</key>
    <type>CODE_SMELL</type>
    <name>Methods and properties that don't access instance data should be static</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Class methods and properties that don't access instance data can be <code>static</code> to prevent any misunderstanding about the contract of the
method. </p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Utilities
{
  public int MagicNum // Noncompliant
  {
    get
    {
      return 42;
    }
  }

  private static string magicWord = "please";
  public string MagicWord  // Noncompliant
  {
    get
    {
      return magicWord;
    }
    set
    {
      magicWord = value;
    }
  }

  public int Sum(int a, int b)  // Noncompliant
  {
    return a + b;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Utilities
{
  public static int MagicNum
  {
    get
    {
      return 42;
    }
  }

  private static string magicWord = "please";
  public static string MagicWord
  {
    get
    {
      return magicWord;
    }
    set
    {
      magicWord = value;
    }
  }

  public static int Sum(int a, int b)
  {
    return a + b;
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S100</key>
    <type>CODE_SMELL</type>
    <name>Methods and properties should be named in camel case</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not method and property names are camel cased. To
reduce noise, two consecutive upper case characters are allowed unless they form the whole name. So, <code>MyXMethod</code> is compliant, but
<code>XM</code> on its own is not.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public int doSomething(){...}
</pre>
<h2>Compliant Solution</h2>
<pre>
public int DoSomething(){...}
</pre>
<h2>Exceptions</h2>
<p>The rule ignores members in types that are marked with <code>ComImportAttribute</code> or <code>InterfaceTypeAttribute</code>. <code>extern</code>
methods are also excluded from the check. Furthermore, when <code>'_'</code> character is found in a name, the camel casing is not enforced.</p>
<pre>
void My_method(){...} // valid
void My_method_(){...} // invalid, leading and trailing underscores are reported
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3427</key>
    <type>CODE_SMELL</type>
    <name>Method overloads with default parameter values should not overlap </name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with optional parameter values
makes the matter even harder to understand. </p>
<p>This rule raises an issue when an overload with default parameter values is hidden by one without the optional parameters. </p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  void Print(string[] messages) {...}
  void Print(string[] messages, string delimiter = "\n") {...} // Noncompliant; default parameter value is hidden by overload
}

// ...
MyClass myClass = new MyClass();

myClass.Print(new string[3] {"yes", "no", "maybe"});  // which version of Print will be called?
</pre>

]]></description>
    <tag>unused</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3600</key>
    <type>CODE_SMELL</type>
    <name>"params" should not be introduced on overrides</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Adding <code>params</code> to a method override has no effect. The compiler accepts it, but the callers won't be able to benefit from the added
modifier.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Base
{
  public virtual void Method(int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(params int[] numbers) // Noncompliant, method can't be called with params syntax.
  {
    ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Base
{
  public virtual void Method(int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(int[] numbers)
  {
    ...
  }
}
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1006</key>
    <type>CODE_SMELL</type>
    <name>Method overrides should not change parameter defaults</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Default arguments are determined by the static type of the object. If a default argument is different for a parameter in an overriding method, the
value used in the call will be different when calls are made via the base or derived object, which may be contrary to developer expectations. </p>
<p>Default parameter values are useless in explicit interface implementations, because the static type of the object will always be the implemented
interface. Thus, specifying default values is useless and confusing.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Base
{
  public virtual void Write(int i = 42)
  {
    Console.WriteLine(i);
  }
}

public class Derived : Base
{
  public override void Write(int i = 5) // Noncompliant
  {
    Console.WriteLine(i);
  }
}

public class Program
{
  public static void Main()
  {
    var derived = new Derived();
    derived.Write(); // writes 5
    Print(derived);  // writes 42; was that expected?
  }
  private void Print(Base item)
  {
    item.Write();
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Base
{
  public virtual void Write(int i = 42)
  {
    Console.WriteLine(i);
  }
}

public class Derived : Base
{
  public override void Write(int i = 42)
  {
    Console.WriteLine(i);
  }
}

public class Program
{
  public static void Main()
  {
    var derived = new Derived();
    derived.Write(); // writes 42
    Print(derived);  // writes 42
  }
  private void Print(Base item)
  {
    item.Write();
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 8-3-1 - Parameters in a overriding virtual function shall either use the same default arguments as the function they override,
  or else shall not specify any default arguments. </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/-YBS">CERT, OOP04-CPP.</a> - Prefer not to give virtual functions default argument
  initializers </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3262</key>
    <type>CODE_SMELL</type>
    <name>"params" should be used on overrides</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Overriding methods automatically inherit the <code>params</code> behavior. To ease readability, this modifier should be explicitly used in the
overriding method as well.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Base
{
  public virtual void Method(params int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(int[] numbers) // Noncompliant, the params is missing.
  {
    ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Base
{
  public virtual void Method(params int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(params int[] numbers)
  {
    ...
  }
}
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3450</key>
    <type>CODE_SMELL</type>
    <name>Parameters with "[DefaultParameterValue]" attributes should also be marked "[Optional]"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus,
<code>[DefaultParameterValue]</code> should always be used in conjunction with <code>[Optional]</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void MyMethod([DefaultParameterValue(5)] int j) //Noncompliant, useless
{
  Console.WriteLine(j);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public void MyMethod(int j = 5)
{
  Console.WriteLine(j);
}
</pre>
<p>or</p>
<pre>
public void MyMethod([DefaultParameterValue(5)][Optional] int j)
{
  Console.WriteLine(j);
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1172</key>
    <type>CODE_SMELL</type>
    <name>Unused method parameters should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void DoSomething(int a, int b) // "b" is unused
{
  Compute(a);
}

void DoSomething2(int a) // value of "a" is unused
{
  a = 10;
  Compute(a);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void DoSomething(int a)
{
  Compute(a);
}

void DoSomething2()
{
  var a = 10;
  Compute(a);
}
</pre>
<h2>Exceptions</h2>
<p><code>virtual</code>, <code>override</code> methods and interface implementations are ignored. </p>
<pre>
override void DoSomething(int a, int b) // no issue reported on b
{
  Compute(a);
}
</pre>
<p>Furthermore, the <code>this</code> parameter of extension methods is also ignored.</p>
<pre>
public static class Extensions
{
  public static void MyHelper(this HtmlHelper helper) //no issue reported here
  {
    // no use of helper here
  }
}
</pre>
<p>Methods that have attributes defined on them are ignored.</p>
<pre>
public class MyDto
{
  public string Name { get; set; }

  [OnDeserialized]
  private void OnDeserialized(StreamingContext context)
  {
    // ...
  }
}
</pre>
<p>Empty or unsupported methods are ignored.</p>
<pre>
public void DoSomething()
{}

public void Call()
{
  throw new NotImplementedException();
}
</pre>
<p>And obviously no issue is raised on the <code>static void Main(string[] args)</code> method</p>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2681</key>
    <type>BUG</type>
    <name>Multiline blocks should be enclosed in curly braces</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Curly braces can be omitted from a one-line block, such as with an <code>if</code> statement or <code>for</code> loop, but doing so can be
misleading and induce bugs. </p>
<p>This rule raises an issue when the indentation of the lines after a one-line block indicates an intent to include those lines in the block, but the
omission of curly braces means the lines will be unconditionally executed once.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (condition)
  FirstActionInBlock();
  SecondAction();  // Noncompliant; executed unconditionally
ThirdAction();

if(condition) FirstActionInBlock(); SecondAction();  // Noncompliant; secondAction executed unconditionally

if(condition) FirstActionInBlock();  // Noncompliant
  SecondAction();  // Executed unconditionally

string str = null;
for (int i = 0; i &lt; array.Length; i++)
  str = array[i];
  DoTheThing(str);  // Noncompliant; executed only on last array element
</pre>
<h2>Compliant Solution</h2>
<pre>
if (condition)
{
  FirstActionInBlock();
  SecondAction();
}
ThirdAction();

string str = null;
for (int i = 0; i &lt; array.Length; i++)
{
  str = array[i];
  DoTheThing(str);
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/483.html">MITRE, CWE-483</a> - Incorrect Block Delimitation </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/3wHEAw">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement
  </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1659</key>
    <type>CODE_SMELL</type>
    <name>Multiple variables should not be declared on the same line</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Declaring multiple variable on one line is difficult to read.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  private int a, b; // Noncompliant

  public void Method()
  {
    int c, d; // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass
{
  private int a;
  private int b;

  public void Method()
  {
    int c;
    int d;
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/7wHEAw">CERT, DCL52-J.</a> - Do not declare more than one variable per declaration
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/VgU">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/fAAhAQ">CERT, DCL04-CPP.</a> - Do not declare more than one variable per declaration
  </li>
</ul>

]]></description>
    <tag>convention</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3887</key>
    <type>BUG</type>
    <name>Mutable, non-private fields should not be "readonly"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using the <code>readonly</code> keyword on a field means that it can't be changed after initialization. However, when applied to collections or
arrays, that's only partly true. <code>readonly</code> enforces that another instance can't be assigned to the field, but it cannot keep the contents
from being updated. That means that in practice, the field value really can be changed, and the use of <code>readonly</code> on such a field is
misleading, and you're likely to not be getting the behavior you expect.</p>
<p>This rule raises an issue when a non-private, <code>readonly</code> field is an array or collection.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  public readonly string[] strings;  // Noncompliant

  // ...
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MyClass
{
  public string[] strings;

  // ...
</pre>
<p>or</p>
<pre>
public class MyClass
{
  private readonly string[] strings;

  // ...
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2386</key>
    <type>VULNERABILITY</type>
    <name>Mutable fields should not be "public static"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>public static</code> mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by
reducing the accessibility of the field or by changing the return type to an immutable type.</p>
<p>This rule raises issues for <code>public static</code> fields with a type inheriting/implementing <code>System.Array</code> or
<code>System.Collections.Generic.ICollection&lt;T&gt;</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class A
{
  public static string[] strings1 = {"first","second"};  // Noncompliant
  public static List&lt;String&gt; strings3 = new List&lt;String&gt;();  // Noncompliant
  // ...
}
</pre>
<h2>Exceptions</h2>
<p>The issue won't raise if the type of the field inherits/implements one (at least) of the following types:</p>
<ul>
  <li> <code>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</code> </li>
  <li> <code>System.Collections.ObjectModel.ReadOnlyDictionary&lt;TKey, TValue&gt;</code> </li>
  <li> <code>System.Collections.Immutable.IImmutableArray&lt;T&gt;</code> </li>
  <li> <code>System.Collections.Immutable.IImmutableDictionary&lt;TKey, TValue&gt;</code> </li>
  <li> <code>System.Collections.Immutable.IImmutableList&lt;T&gt;</code> </li>
  <li> <code>System.Collections.Immutable.IImmutableSet&lt;T&gt;</code> </li>
  <li> <code>System.Collections.Immutable.IImmutableStack&lt;T&gt;</code> </li>
  <li> <code>System.Collections.Immutable.IImmutableQueue&lt;T&gt;</code> </li>
</ul>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/582.html">MITRE, CWE-582</a> - Array Declared Public, Final, and Static </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/607.html">MITRE, CWE-607</a> - Public Static Final Field References Mutable Object </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/rwBc">CERT, OBJ01-J.</a> - Limit accessibility of fields </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/JQLEAw">CERT, OBJ13-J.</a> - Ensure that references to mutable objects are not exposed
  </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>unpredictable</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1163</key>
    <type>CODE_SMELL</type>
    <name>Exceptions should not be thrown in finally blocks</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Throwing an exception from within a finally block will mask any exception which was previously thrown in the <code>try</code> or <code>catch</code>
block, and the masked's exception message and stack trace will be lost.</p>
<h2>Noncompliant Code Example</h2>
<pre>
try
{
  /* some work which end up throwing an exception */
  throw new ArgumentException();
}
finally
{
  /* clean up */
  throw new InvalidOperationException();       // Noncompliant; will mask the ArgumentException
}
</pre>
<h2>Compliant Solution</h2>
<pre>
try
{
  /* some work which end up throwing an exception */
  throw new ArgumentException();
}
finally
{
  /* clean up */                       // Compliant
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/soUbAQ">CERT, ERR05-J.</a> - Do not let checked exceptions escape from a finally block
  </li>
</ul>

]]></description>
    <tag>error-handling</tag>
    <tag>cert</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3265</key>
    <type>CODE_SMELL</type>
    <name>Non-flags enums should not be used in bitwise operations</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>enum</code>s are usually used to identify distinct elements in a set of values. However <code>enum</code>s can be treated as bit fields and
bitwise operations can be used on them to combine the values. This is a good way of specifying multiple elements of set with a single value. When
<code>enum</code>s are used this way, it is a best practice to mark the <code>enum</code> with the <code>FlagsAttribute</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
enum Permissions
{
  None = 0,
  Read = 1,
  Write = 2,
  Execute = 4
}
// ...

var x = Permissions.Read | Permissions.Write;  // Noncompliant; enum is not marked with [Flags]
</pre>
<h2>Compliant Solution</h2>
<pre>
[Flags]
enum Permissions
{
  None = 0,
  Read = 1,
  Write = 2,
  Execute = 4
}
// ...

var x = Permissions.Read | Permissions.Write;
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4040</key>
    <type>CODE_SMELL</type>
    <name>Strings should be normalized to uppercase</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Certain characters, once normalized to lowercase, cannot make a round trip, meaning that they can not be converted from one locale to another and
then accurately restored to their original characters.</p>
<p>It is therefore strongly recommended to normalize strings to uppercase instead.</p>
<h2>Noncompliant Code Example</h2>
<pre>
String s = myString.ToLower(CultureInfo.InvariantCulture);  // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
String s = myString.ToUpper(CultureInfo.InvariantCulture);
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3459</key>
    <type>CODE_SMELL</type>
    <name>Unassigned members should be removed</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely,
mistakes. </p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  private int field; // Noncompliant, shouldn't it be initialized? This way the value is always default(int), 0.
  private int Property { get; set; }  // Noncompliant
  public void Print()
  {
    Console.WriteLine(field); //Will always print 0
    Console.WriteLine(Property); //Will always print 0
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass
{
  private int field;
  private int Property { get; set; } = 42;
  public void Print()
  {
    field++;
    Console.WriteLine(field);
    Console.WriteLine(Property);
  }
}
</pre>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2259</key>
    <type>BUG</type>
    <name>Null pointers should not be dereferenced</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A reference to <code>null</code> should never be dereferenced/accessed. Doing so will cause a <code>NullReferenceException</code> to be thrown. At
best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or
it could allow an attacker to bypass security measures.</p>
<h2>Noncompliant Code Example</h2>
<pre>
object o = null;
if (condition)
{
  M1(o.ToString()); // Noncompliant, always null
}
else
{
  o = new object();
}
M2(o.ToString());
</pre>
<h2>Exceptions</h2>
<p>Calls to extension methods are not reported because they can still operate on <code>null</code> values.</p>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/476.html">MITRE, CWE-476</a> - NULL Pointer Dereference </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/PAw">CERT, EXP34-C.</a> - Do not dereference null pointers </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/ZwDOAQ">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required
  </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1848</key>
    <type>BUG</type>
    <name>Objects should not be created to be dropped immediately without being used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could
lead to an unexpected behavior in production.</p>
<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate, static method and
called directly.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (x &lt; 0)
  new ArgumentException("x must be nonnegative");
</pre>
<h2>Compliant Solution</h2>
<pre>
if (x &lt; 0)
  throw new ArgumentException("x must be nonnegative");
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1123</key>
    <type>CODE_SMELL</type>
    <name>"Obsolete" attributes should include explanations</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>Obsolete</code> attribute can be applied with or without arguments, but marking something <code>Obsolete</code> without including advice
as to why it's obsolete or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time the
warning is encountered.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Car
{

  [Obsolete]  // Noncompliant
  public void CrankEngine(int turnsOfCrank)
  { ... }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Car
{

  [Obsolete("Replaced by the automatic starter")]
  public void CrankEngine(int turnsOfCrank)
  { ... }
}
</pre>

]]></description>
    <tag>obsolete</tag>
    <tag>bad-practice</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2360</key>
    <type>CODE_SMELL</type>
    <name>Optional parameters should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The overloading mechanism should be used in place of optional parameters for several reasons:</p>
<ul>
  <li> Optional parameter values are baked into the method call site code, thus, if a default value has been changed, all referencing assemblies need
  to be rebuilt, otherwise the original values will be used. </li>
  <li> The Common Language Specification (CLS) allows compilers to ignore default parameter values, and thus require the caller to explicitly specify
  the values. </li>
  <li> The concept of optional argument exists only in VB.Net and C#. In all other languages like C++ or Java, the overloading mechanism is the only
  way to get the same behavior. </li>
  <li> Optional parameters prevent muddying the definition of the function contract. Here is a simple example: if there are two optional parameters,
  when one is defined, is the second one still optional or mandatory? </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
void Notify(string company, string office = "QJZ") // Noncompliant
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void Notify(string company)
{
  Notify(company, "QJZ");
}
void Notify(string company, string office)
{
}
</pre>
<h2>Exceptions</h2>
<p>The rule ignores non externally visible methods.</p>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3466</key>
    <type>BUG</type>
    <name>Optional parameters should be passed to "base" calls</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Generally, writing the least code that will <em>readably</em> do the job is a good thing, so omitting default parameter values seems to make sense.
Unfortunately, when you omit them from the <code>base</code> call in an override, you're not actually getting the job done thoroughly, because you're
ignoring the value the caller passed in. The result will likely not be what the caller expected.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class BaseClass
{
    public virtual void MyMethod(int i = 1)
    {
        Console.WriteLine(i);
    }
}

public class DerivedClass : BaseClass
{
    public override void MyMethod(int i = 1)
    {
        // ...
        base.MyMethod(); // Noncompliant; caller's value is ignored
    }

    static int Main(string[] args)
    {
        DerivedClass dc = new DerivedClass();
        dc.MyMethod(12);  // prints 1
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class BaseClass
{
    public virtual void MyMethod(int i = 1)
    {
        Console.WriteLine(i);
    }
}

public class DerivedClass : BaseClass
{
    public override void MyMethod(int i = 1)
    {
        // ...
        base.MyMethod(i);
    }

    static int Main(string[] args)
    {
        DerivedClass dc = new DerivedClass();
        dc.MyMethod(12);  // prints 12
    }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3451</key>
    <type>CODE_SMELL</type>
    <name>"[DefaultValue]" should not be used when "[DefaultParameterValue]" is meant</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The use of <code>[DefaultValue]</code> with <code>[Optional]</code> has no more effect than <code>[Optional]</code> alone. That's because
<code>[DefaultValue]</code> doesn't actually do anything; it merely indicates the intent for the value. More than likely, <code>[DefaultValue]</code>
was used in confusion instead of <code>[DefaultParameterValue]</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
    public void DoStuff([Optional][DefaultValue(4)]int i, int j = 5)  // Noncompliant
    {
        Console.WriteLine(i);
    }

    public static void Main()
    {
        new MyClass().DoStuff(); // prints 0
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass
{
    public void DoStuff([Optional][DefaultParameterValue(4)]int i, int j = 5)
    {
        Console.WriteLine(i);
    }

    public static void Main()
    {
        new MyClass().DoStuff(); // prints 4
    }
}
</pre>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3447</key>
    <type>CODE_SMELL</type>
    <name>"[Optional]" should not be used on "ref" or "out" parameters</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The use of <code>ref</code> or <code>out</code> in combination with <code>[Optional]</code> is both confusing and contradictory.
<code>[Optional]</code> indicates that the parameter doesn't have to be provided, while <code>out</code> and <code>ref</code> mean that the parameter
will be used to return data to the caller (<code>ref</code> additionally indicates that the parameter may also be used to pass data into the
method).</p>
<p>Thus, making it <code>[Optional]</code> to provide the parameter in which you will be passing back the method results doesn't make sense. In fact,
the compiler will raise an error on such code. Unfortunately, it raises the error on method calls where the <code>[Optional]</code> parameter has been
omitted, not the source of the problem, the method declaration. </p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
    public void DoStuff([Optional] ref int i) // Noncompliant
    {
        Console.WriteLine(i);
    }

    public static void Main()
    {
        new MyClass().DoStuff(); // This doesn't compile, CS7036 shows
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass
{
  public void DoStuff(ref int i)
  {
    Console.WriteLine(i);
  }

  public static void Main()
  {
    var i = 42;
    new MyClass().DoStuff(ref i);
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3169</key>
    <type>CODE_SMELL</type>
    <name>Multiple "OrderBy" calls should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>There's no point in chaining multiple <code>OrderBy</code> calls in a LINQ; only the last one will be reflected in the result because each
subsequent call completely reorders the list. Thus, calling <code>OrderBy</code> multiple times is a performance issue as well, because all of the
sorting will be executed, but only the result of the last sort will be kept.</p>
<p>Instead, use <code>ThenBy</code> for each call after the first. </p>
<h2>Noncompliant Code Example</h2>
<pre>
var x = personList
  .OrderBy(person =&gt; person.Age)
  .OrderBy(person =&gt; person.Name)  // Noncompliant
  .ToList();  // x is sorted by Name, not sub-sorted
</pre>
<h2>Compliant Solution</h2>
<pre>
var x = personList
  .OrderBy(person =&gt; person.Age)
  .ThenBy(person =&gt; person.Name)
  .ToList();
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1206</key>
    <type>BUG</type>
    <name>"Equals(Object)" and "GetHashCode()" should be overridden in pairs</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>There is a contract between <code>Equals(object)</code> and <code>GetHashCode()</code>: If two objects are equal according to the
<code>Equals(object)</code> method, then calling <code>GetHashCode()</code> on each of them must yield the same result. If this is not the case, many
collections won't handle class instances correctly.</p>
<p>In order to comply with the contract, <code>Equals(object)</code> and <code>GetHashCode()</code> should be either both inherited, or both
overridden.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass {    // Noncompliant - should also override "hashCode()"

  @Override
  public boolean equals(Object obj) {
    /* ... */
  }

}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass {    // Compliant

  @Override
  public boolean equals(Object obj) {
    /* ... */
  }

  @Override
  public int hashCode() {
    /* ... */
  }

}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/581.html">MITRE, CWE-581</a> - Object Model Violation: Just One of Equals and Hashcode Defined
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/EYYbAQ">CERT, MET09-J.</a> - Classes that define an equals() method must also define a
  hashCode() method </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15 min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1226</key>
    <type>CODE_SMELL</type>
    <name>Method parameters and caught exceptions should not be reassigned</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate
results.</p>
<p>This rule will typically detect cases where a constructor parameter is assigned to itself instead of a field of the same name, i.e. when
<code>this</code> was forgotten.</p>
<p>Allowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or
some temporary variable is being accessed without going through the whole method.</p>
<p>Moreover, some developers might also expect assignments of method parameters to be visible from callers, which is not the case and can confuse
them.</p>
<p>All parameters should be treated as <code>readonly</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  public string name;

  public MyClass(string name)
  {
    name = name;                    // Noncompliant - useless identity assignment
  }

  public int Add(int a, int b)
  {
    a = a + b;                      // Noncompliant

    /* additional logic */

    return a;                       // Seems like the parameter is returned as is, what is the point?
  }

  public static void Main()
  {
    MyClass foo = new MyClass();
    int a = 40;
    int b = 2;
    foo.Add(a, b);                  // Variable "a" will still hold 40 after this call
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass
{
  public string name;

  public MyClass(string name)
  {
    this.name = name;               // Compliant
  }

  public int Add(int a, int b)
  {
    return a + b;                   // Compliant
  }

  public static void Main()
  {
    MyClass foo = new MyClass();
    int a = 40;
    int b = 2;
    foo.Add(a, b);
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2012, 17.8 - A function parameter should not be modified </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S927</key>
    <type>CODE_SMELL</type>
    <name>"partial" method parameter names should match</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When the parameters to the implementation of a <code>partial</code> method don't match those in the signature declaration, then confusion is almost
guaranteed. Either the implementer was confused when he renamed, swapped or mangled the parameter names in the implementation, or callers will be
confused.</p>
<h2>Noncompliant Code Example</h2>
<pre>
partial class Point
{
  partial void MoveVertically(int z);
}

partial class Point
{
  int x = 0;
  int y = 0;
  int z = 0;

  partial void MoveVertically(int y)  // Noncompliant
  {
    this.y = y;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
partial class Point
{
  partial void MoveVertically(int z);
}

partial class Point
{
  int x = 0;
  int y = 0;
  int z = 0;

  partial void MoveVertically(int z)
  {
    this.z = z;
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 8.3 - For each function parameter the type given in the declaration and definition shall be identical, and the return types shall
  also be identical </li>
  <li> MISRA C:2004, 16.4 - The identifiers used in the declaration and definition of a function shall be identical. </li>
  <li> MISRA C++:2008, 8-4-2 - The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the
  declaration. </li>
  <li> MISRA C:2012, 8.3 - All declarations of an object or function shall use the same names and type qualifiers. </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/cwGTAw">CERT, DCL40-C.</a> - Do not create incompatible declarations of the same
  function or object </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3872</key>
    <type>CODE_SMELL</type>
    <name>Parameter names should not duplicate the names of their methods</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The name of a method should communicate what it does, and the names of its parameters should indicate how they're used. If a method and its
parameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language
that's not the case, it is still likely to confuse callers and maintainers.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void Login(string login)  // Noncompliant
{
  //...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public void Login(string userName)
{
  //...
}
</pre>

]]></description>
    <tag>convention</tag>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2234</key>
    <type>BUG</type>
    <name>Parameters should be passed in the correct order</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when
the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead
to unexpected results.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public double Divide(int divisor, int dividend)
{
  return divisor/dividend;
}

public void DoTheThing()
{
  int divisor = 15;
  int dividend = 5;

  double result = Divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected
  //...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public double Divide(int divisor, int dividend)
{
  return divisor/dividend;
}

public void DoTheThing()
{
  int divisor = 15;
  int dividend = 5;

  double result = Divide(divisor, dividend);
  //...
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3251</key>
    <type>CODE_SMELL</type>
    <name>Implementations should be provided for "partial" methods</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>partial</code> methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking
methods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to
production, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are
critical, missing functionality, the loss of which will lead to unexpected results at runtime.</p>
<p>This rule raises an issue for partial methods for which no implementation can be found in the assembly.</p>
<h2>Noncompliant Code Example</h2>
<pre>
partial class C
{
  partial void M(); //Noncompliant

  void OtherM()
  {
    M(); //Noncompliant. Will be removed.
  }
}
</pre>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4000</key>
    <type>CODE_SMELL</type>
    <name>Pointers to unmanaged memory should not be visible</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>IntPtr</code> and <code>UIntPtr</code> types are used to access unmanaged memory, usually in order to use C or C++ libraries. If such a
pointer is not secured by making it <code>private</code>, <code>internal</code> or <code>readonly</code>, it can lead to a vulnerability allowing
access to arbitrary locations.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
  public class MyClass
  {
    public IntPtr myPointer;  // Noncompliant
    protected UIntPtr myOtherPointer; // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
  public class MyClass
  {
    private IntPtr myPointer;
    protected readonly UIntPtr myOtherPointer;
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3967</key>
    <type>CODE_SMELL</type>
    <name>Multidimensional arrays should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements
can be of different sizes, which avoids wasting memory space.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int [,] myArray =  // Noncompliant
    {
        {1,2,3,4},
        {5,6,7,0},
        {8,0,0,0},
        {9,0,0,0}
    };
// ...
myArray[1,1] = 0;
</pre>
<h2>Compliant Solution</h2>
<pre>
int[][] myArray =
    {
        new int[] {1,2,3,4},
        new int[] {5,6,7},
        new int[] {8},
        new int[] {9}
    };
// ...
myArray[1][1] = 0;
</pre>

]]></description>
    <tag>design</tag>
    <remediationFunctionBaseEffort />
  </rule>
  <rule>
    <key>S1450</key>
    <type>CODE_SMELL</type>
    <name>Private fields only used as local variables in methods should become local variables</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class
information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
  private int singularField;

  public void DoSomething(int x)
  {
    singularField = x + 5;

    if (singularField == 0) { /* ... */ }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo
{
  public void DoSomething(int x)
  {
    int localVariable = x + 5;

    if (localVariable == 0) { /* ... */ }
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2372</key>
    <type>CODE_SMELL</type>
    <name>Exceptions should not be thrown from property getters</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a
method. </p>
<p>It is valid to throw exceptions from indexed property getters and from property setters, which are not detected by this rule.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public int Foo
{
  get
  {
    throw new Exception(); // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
Module Module1
    Sub SetFoo(ByVal value As Integer)         ' Compliant
        ' ... some code ...
    End Sub
End Module
</pre>
<h2>Exceptions</h2>
<p>No issue is raised when the thrown exception derives from or is of type <code>NotImplementedException</code>, <code>NotSupportedException</code> or
<code>PlatformNotSupportedException</code>.</p>

]]></description>
    <tag>error-handling</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2292</key>
    <type>CODE_SMELL</type>
    <name>Trivial properties should be auto-implemented</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding
cleaner and more readable code.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Car
{
  private string _make;
  public string Make // Noncompliant
  {
    get { return _make; }
    set { _make = value; }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Car
{
  public string Make { get; set; }
}
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2376</key>
    <type>CODE_SMELL</type>
    <name>Write-only properties should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or the property should be
replaced with a setter method.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Program
{
    public int Foo  //Non-Compliant
    {
        set
        {
            // ... some code ...
        }
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Program
{
    private int foo;

    public void SetFoo(int value)
    {
        // ... some code ...
        foo = value;
    }
}
</pre>
<p>or</p>
<pre>
class Program
{
  public int Foo { get; set; } // Compliant
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3926</key>
    <type>BUG</type>
    <name>Deserialization methods should be provided for "OptionalField" members</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Fields marked with <code>System.Runtime.Serialization.OptionalFieldAttribute</code> are serialized just like any other field. But such fields are
ignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to
set such fields during the deserialization process.</p>
<p>This rule raises when at least one field with the <code>System.Runtime.Serialization.OptionalFieldAttribute</code> attribute is declared but one
(or both) of the following event handlers <code>System.Runtime.Serialization.OnDeserializingAttribute</code> or
<code>System.Runtime.Serialization.OnDeserializedAttribute</code> are not present.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[Serializable]
public class Foo
{
    [OptionalField(VersionAdded = 2)]
    int optionalField = 5;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
[Serializable]
public class Foo
{
    [OptionalField(VersionAdded = 2)]
    int optionalField = 5;

    [OnDeserializing]
    void OnDeserializing(StreamingContext context)
    {
	    optionalField = 5;
    }

    [OnDeserialized]
    void OnDeserialized(StreamingContext context)
    {
        // Set optionalField if dependent on other deserialized values.
    }
}
</pre>

]]></description>
    <tag>serialization</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2339</key>
    <type>CODE_SMELL</type>
    <name>Public constant members should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Constant members are copied at compile time to the call sites, instead of being fetched at runtime.</p>
<p>As an example, say you have a library with a constant <code>Version</code> member set to <code>1.0</code>, and a client application linked to it.
This library is then updated and <code>Version</code> is set to <code>2.0</code>. Unfortunately, even after the old DLL is replaced by the new one,
<code>Version</code> will still be <code>1.0</code> for the client application. In order to see <code>2.0</code>, the client application would need to
be rebuilt against the new version of the library.</p>
<p>This means that you should use constants to hold values that by definition will never change, such as <code>Zero</code>. In practice, those cases
are uncommon, and therefore it is generally better to avoid constant members.</p>
<p>This rule only reports issues on public constant fields, which can be reached from outside the defining assembly.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
    public const double Version = 1.0;           // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo
{
    public static double Version
    {
      get { return 1.0; }
    }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2368</key>
    <type>CODE_SMELL</type>
    <name>Public methods should not have multidimensional array parameters</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Exposing methods with multidimensional array parameters requires developers to have advanced knowledge about the language in order to be able to
use them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods should not be exposed, but can be used
internally.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Program
{
    public void WriteMatrix(int[][] matrix) // Non-Compliant
    {
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Matrix
{
    // ...
}

public class Program
{
    public void WriteMatrix(Matrix matrix) // Compliant
    {
    }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1h</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3603</key>
    <type>BUG</type>
    <name>Methods with "Pure" attribute should return a value </name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Marking a method with the <code>[Pure]</code> attribute specifies that the method doesn't make any visible changes; thus, the method should return
a result, otherwise the call to the method should be equal to no-operation. So <code>[Pure]</code> on a <code>void</code> method is either a mistake,
or the method doesn't do any meaningful task.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Person
{
  private int age;
  [Pure] // Noncompliant. In this case the method makes a possibly visible state change
  void ConfigureAge(int age)
  {
    ...
    this.age = age;
  }
  ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Person
{
  private int age;

  void ConfigureAge(int age)
  {
    ...
    this.age = age;
  }
  ...
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3253</key>
    <type>CODE_SMELL</type>
    <name>Constructor and destructor declarations should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Since the compiler will automatically invoke the base type's no-argument constructor, there's no need to specify its invocation explicitly. Also,
when only a single <code>public</code> parameterless constructor is defined in a class, then that constructor can be removed because the compiler
would generate it automatically. Similarly, empty <code>static</code> constructors and empty destructors are also wasted keystrokes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class X
{
  public X() { } // Noncompliant
  static X() { }  // Noncompliant
  ~X() { } // Noncompliant

  ...
}

class Y : X
{
  public Y(int parameter) : base() // Noncompliant
  {
    /* does something with the parameter */
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class X
{
  ...
}

class Y : X
{
  public Y(int parameter)
  {
    /* does something with the parameter */
  }
}
</pre>

]]></description>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3254</key>
    <type>CODE_SMELL</type>
    <name>Default parameter values should not be passed as arguments</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void M(int x, int y=5, int z = 7) { /* ... */ }

// ...
M(1, 5); //Noncompliant, y has the default value
M(1, z: 7); //Noncompliant, z has the default value
</pre>
<h2>Compliant Solution</h2>
<pre>
public void M(int x, int y=5, int z = 7) { /* ... */ }

// ...
M(1);
M(1);
</pre>

]]></description>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1905</key>
    <type>CODE_SMELL</type>
    <name>Redundant casts should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Unnecessary casting expressions make the code harder to read and understand.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public int Example(int i)
{
  return (int) (i + 42); // Noncompliant
}
public IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)
{
  return coll.Reverse().OfType&lt;int&gt;(); // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public int Example(int i)
{
  return i + 42;
}
public IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)
{
  return coll.Reverse();
}
</pre>

]]></description>
    <tag>redundant</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3440</key>
    <type>CODE_SMELL</type>
    <name>Variables should not be checked against the values they're about to be assigned</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>There's no point in checking a variable against the value you're about to assign it. Save the cycles and lines of code, and simply perform the
assignment.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (x != a)  // Noncompliant; why bother?
{
  x = a;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
x = a;
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3257</key>
    <type>CODE_SMELL</type>
    <name>Declarations and initializations should be as concise as possible</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified.</p>
<p>Specifically the following should be omitted when they can be inferred:</p>
<ul>
  <li> array element type </li>
  <li> array size </li>
  <li> <code>new DelegateType</code> </li>
  <li> <code>new Nullable&lt;Type&gt;</code> </li>
  <li> object or collection initializers (<code>{</code>}) </li>
  <li> type of lambda expression parameters </li>
  <li> parameter declarations of anonymous methods when the parameters are not used. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
var l = new List&lt;int&gt;() {}; // Noncompliant, {} can be removed
var o = new object() {}; // Noncompliant, {} can be removed

var ints = new int[] {1, 2, 3}; // Noncompliant, int can be omitted
ints = new int[3] {1, 2, 3}; // Noncompliant, the size specification can be removed

int? i = new int?(5); // Noncompliant new int? could be omitted, it can be inferred from the declaration, and there's implicit conversion from T to T?
var j = new int?(5);

Func&lt;int, int&gt; f1 = (int i) =&gt; 1; //Noncompliant, can be simplified

class Class
{
    private event EventHandler MyEvent;

    public Class()
    {
        MyEvent += new EventHandler((a,b)=&gt;{ }); // Noncompliant, needlessly verbose
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
var l = new List&lt;int&gt;();
var o = new object();

var ints = new [] {1, 2, 3};
ints = new [] {1, 2, 3};

int? i = 5;
var j = new int?(5);

Func&lt;int, int&gt; f1 = (i) =&gt; 1;

class Class
{
    private event EventHandler MyEvent;

    public Class()
    {
        MyEvent += (a,b)=&gt;{ };
    }
}
</pre>

]]></description>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1939</key>
    <type>CODE_SMELL</type>
    <name>Inheritance list should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>An inheritance list entry is redundant if:</p>
<ul>
  <li> It is <code>Object</code> - all classes extend <code>Object</code> implicitly. </li>
  <li> It is <code>int</code> for an <code>enum</code> </li>
  <li> It is a base class of another listed inheritance. </li>
</ul>
<p>Such redundant declarations should be removed because they needlessly clutter the code and can be confusing.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass : Object  // Noncompliant

enum MyEnum : int  // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MyClass

enum MyEnum
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3626</key>
    <type>CODE_SMELL</type>
    <name>Jump statements should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Jump statements, such as <code>return</code>, <code>yield break</code>, <code>goto</code>, and <code>continue</code> let you change the default
flow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void Foo()
{
  goto A; // Noncompliant
  A:
  while (condition1)
  {
    if (condition2)
    {
      continue; // Noncompliant
    }
    else
    {
      DoTheThing();
    }
  }
  return; // Noncompliant; this is a void method
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void Foo()
{
  while (condition1)
  {
    if (!condition2)
    {
      DoTheThing();
    }
  }
}
</pre>

]]></description>
    <tag>finding</tag>
    <tag>redundant</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2333</key>
    <type>CODE_SMELL</type>
    <name>Redundant modifiers should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Unnecessary keywords simply clutter the code and should be removed. Specifically:</p>
<ul>
  <li> <code>partial</code> on type declarations that are completely defined in one place </li>
  <li> <code>sealed</code> on members of <code>sealed</code> classes </li>
  <li> <code>unsafe</code> method or block inside construct already marked with <code>unsafe</code>, or when there are no <code>unsafe</code>
  constructs in the block </li>
  <li> <code>checked</code> and <code>unchecked</code> blocks with no integral-type arithmetic operations </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
public partial class MyClass // Noncompliant
{
  public virtual void Method()
  {
  }
}

public sealed class MyOtherClass : MyClass
{
  public sealed override void Method() // Noncompliant
  {
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MyClass
{
  public virtual void Method()
  {
  }
}

public sealed class MyOtherClass : MyClass
{
  public override void Method()
  {
  }
}
</pre>

]]></description>
    <tag>unused</tag>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3610</key>
    <type>BUG</type>
    <name>Nullable type comparison should not be redundant</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Calling <code>GetType()</code> on a nullable object returns the underlying value type. Thus, comparing the returned <code>Type</code> object to
<code>typeof(Nullable&lt;SomeType&gt;)</code> doesn't make sense. The comparison either throws an exception or the result can be known at compile
time.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int? nullable = 42;
bool comparison = nullable.GetType() == typeof(Nullable&lt;int&gt;); // Noncompliant, always false
comparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, always true

nullable = null;
comparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, calling GetType on a null always throws an exception
</pre>

]]></description>
    <tag>redundant</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3235</key>
    <type>CODE_SMELL</type>
    <name>Redundant parentheses should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Redundant parentheses are simply wasted keystrokes, and should be removed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[MyAttribute()] //Noncompliant
class MyClass
{
  public int MyProperty { get; set; }
  public static MyClass CreateNew(int propertyValue)
  {
    return new MyClass() //Noncompliant
    {
      MyProperty = propertyValue
    };
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
[MyAttribute]
class MyClass
{
  public int MyProperty { get; set; }
  public static MyClass CreateNew(int propertyValue)
  {
    return new MyClass
    {
      MyProperty = propertyValue
    };
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>unused</tag>
    <tag>finding</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3441</key>
    <type>CODE_SMELL</type>
    <name>Redundant property names should be omitted in anonymous classes</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When an anonymous type's properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type's
property name and the assignment operator.</p>
<h2>Noncompliant Code Example</h2>
<pre>
var X = 5;

var anon = new
{
  X = X, //Noncompliant, the new object would have the same property without the "X =" part.
  Y = "my string"
};
</pre>
<h2>Compliant Solution</h2>
<pre>
var X = 5;

var anon = new
{
  X,
  Y = "my string"
};
</pre>

]]></description>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3456</key>
    <type>BUG</type>
    <name>"string.ToCharArray()" should not be called redundantly</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>ToCharArray</code> can be omitted when the operation on the array could have been done directly on the string, such as when iterating over
the characters in a string, and when accessing a character in a string via an array index. In those cases, explicit <code>ToCharArray</code> calls
should be omitted.</p>
<h2>Noncompliant Code Example</h2>
<pre>
string str = "some string";
foreach (var c in str.ToCharArray()) // Noncompliant
{
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
string str = "some string";
foreach (var c in str)
{
  // ...
}
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1858</key>
    <type>CODE_SMELL</type>
    <name>"ToString()" calls should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly
invoking <code>ToString()</code> when the compiler would do it implicitly is also needless code-bloat.</p>
<p>This rule raises an issue when <code>ToString()</code> is invoked:</p>
<ul>
  <li> on a <code>string</code> </li>
  <li> on a non-<code>string</code> operand to concatenation </li>
  <li> on an argument to <code>string.Format</code> </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
var s = "foo";
var t = "fee fie foe " + s.ToString();  // Noncompliant
var someObject = new object();
var u = "" + someObject.ToString(); // Noncompliant
var v = string.Format("{0}", someObject.ToString()); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
var s = "foo";
var t = "fee fie foe " + s;
var someObject = new object();
var u = "" + someObject;
var v = string.Format("{0}", someObject);
</pre>
<h2>Exceptions</h2>
<p>The rule does not report on value types, where leaving off the <code>ToString()</code> call would result in automatic boxing.</p>
<pre>
var v = string.Format("{0}", 1.ToString());
</pre>

]]></description>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1698</key>
    <type>CODE_SMELL</type>
    <name>"==" should not be used when "Equals" is overridden</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using the equality <code>==</code> and inequality <code>!=</code> operators to compare two objects generally works. The operators can be
overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then
<code>==</code> resolves to reference equality, which may result in unexpected behavior if implementing classes override <code>Equals</code>.
Similarly, when a class overrides <code>Equals</code>, but instances are compared with non-overloaded <code>==</code>, there is a high chance that
value comparison was meant instead of the reference one.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public interface IMyInterface
{
}

public class MyClass : IMyInterface
{
    public override bool Equals(object obj)
    {
        //...
    }
}

public class Program
{
    public static void Method(IMyInterface instance1, IMyInterface instance2)
    {
        if (instance1 == instance2) // Noncompliant, will do reference equality check, but was that intended? MyClass overrides Equals.
        {
            Console.WriteLine("Equal");
        }
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public interface IMyInterface
{
}

public class MyClass : IMyInterface
{
    public override bool Equals(object obj)
    {
        //...
    }
}

public class Program
{
    public static void Method(IMyInterface instance1, IMyInterface instance2)
    {
        if (object.Equals(instance1, instance2)) // object.Equals checks for null and then calls the instance based Equals, so MyClass.Equals
        {
            Console.WriteLine("Equal");
        }
    }
}
</pre>
<h2>Exceptions</h2>
<p>The rule does not report on comparisons of <code>System.Type</code> instances and on comparisons inside <code>Equals</code> overrides.</p>
<p>It also does not raise an issue when one of the operands is <code>null</code> nor when one of the operand is cast to <code>object</code> (because
in this case we want to ensure reference equality even if some <code>==</code> overload is present).</p>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/595.html">MITRE, CWE-595</a> - Comparison of Object References Instead of Object Contents </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/597.html">MITRE, CWE-597</a> - Use of Wrong Operator in String Comparison </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/wwD1AQ">CERT, EXP03-J.</a> - Do not use the equality operators when comparing values of
  boxed primitives </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/8AEqAQ">CERT, EXP50-J.</a> - Do not confuse abstract object equality with reference
  equality </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>cert</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2995</key>
    <type>BUG</type>
    <name>"Object.ReferenceEquals" should not be used for value types</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using <code>Object.ReferenceEquals</code> to compare the references of two value types simply won't return the expected results most of the time
because such types are passed by value, not by reference.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  private MyStruct myStruct;

  public void DoSomething(MyStruct s1) {
    int a = 1;
    int b = 1;

    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true
    {
      // ...
    }
    else if (Object.ReferenceEquals(a,b)) // Noncompliant
    {
      // ...
    }
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3993</key>
    <type>CODE_SMELL</type>
    <name>Custom attributes should be marked with "System.AttributeUsageAttribute"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When defining custom attributes, <code>System.AttributeUsageAttribute</code> must be used to indicate where the attribute can be applied. This will
determine its valid locations in the code.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{

   public sealed class MyAttribute :Attribute // Noncompliant
   {
      string text;

      public MyAttribute(string myText)
      {
         text = myText;
      }
      public string Text
      {
         get
         {
            return text;
         }
      }
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{

   [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Interface | AttributeTargets.Delegate)]
   public sealed class MyAttribute :Attribute
   {
      string text;

      public MyAttribute(string myText)
      {
         text = myText;
      }
      public string Text
      {
         get
         {
            return text;
         }
      }
   }
}
</pre>

]]></description>
    <tag>api-design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2201</key>
    <type>BUG</type>
    <name>Return values from functions without side effects should not be ignored</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When the call to a function doesn't have any side effects, what is the point of making the call if the results are ignored? In such case, either
the function call is useless and should be dropped or the source code doesn't behave as expected.</p>
<p>This rule raises an issue when the results of the following methods are ignored:</p>
<ul>
  <li> LINQ method, </li>
  <li> <code>[Pure]</code> method, </li>
  <li> any method on <code>string</code>, <code>int</code>, ..., <code>System.Collections.Immutable.ImmutableArray&lt;T&gt;</code>,
  <code>ImmutableHashSet&lt;T&gt;</code>, ... </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
coll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i); // Noncompliant
"this string".Equals("other string"); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
var res = coll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i);
var isEqual = "this string".Equals("other string");
</pre>
<h2>Exceptions</h2>
<p>This rule doesn't report issues on method calls with <code>out</code> or <code>ref</code> arguments.</p>
<h2>See</h2>
<ul>
  <li> MISRA C:2012, 17.7 - The value returned by a function having non-void return type shall be used </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/9YIRAQ">CERT, EXP12-C.</a> - Do not ignore values returned by functions </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/eoAyAQ">CERT, EXP12-CPP.</a> - Do not ignore values returned by functions or methods
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/9gEqAQ">CERT, EXP00-J.</a> - Do not ignore values returned by methods </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2757</key>
    <type>BUG</type>
    <name>"=+" should not be used instead of "+="</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The use of operators pairs ( <code>=+</code>, <code>=-</code> or <code>=\!</code> ) where the reversed, single operator was meant (<code>+=</code>,
<code>-=</code> or <code>\!=</code>) will compile and run, but not produce the expected results.</p>
<p>This rule raises an issue when <code>=+</code>, <code>=-</code>, or <code>=!</code> is used without any spacing between the two operators and when
there is at least one whitespace character after.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int target = -5;
int num = 3;

target =- num;  // Noncompliant; target = -3. Is that really what's meant?
target =+ num; // Noncompliant; target = 3
</pre>
<h2>Compliant Solution</h2>
<pre>
int target = -5;
int num = 3;

target = -num;  // Compliant; intent to assign inverse value of num is clear
target += num;
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1109</key>
    <type>CODE_SMELL</type>
    <name>A close curly brace should be located at the beginning of a line</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the
beginning of a line.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if(condition)
{
  doSomething();}
</pre>
<h2>Compliant Solution</h2>
<pre>
if(condition)
{
  doSomething();
}
</pre>
<h2>Exceptions</h2>
<p>When blocks are inlined (open and close curly braces on the same line), no issue is triggered. </p>
<pre>
if(condition) {doSomething();}
</pre>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3884</key>
    <type>VULNERABILITY</type>
    <name>"CoSetProxyBlanket" and "CoInitializeSecurity" should not be used</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>CoSetProxyBlanket</code> and <code>CoInitializeSecurity</code> both work to set the permissions context in which the process invoked
immediately after is executed. Calling them from within that process is useless because it's to late at that point; the permissions context has
already been set.</p>
<p>Specifically, these methods are meant to be called from a non-managed code such as a C++ wrapper that then invokes the managed, i.e. C# or VB.NET,
code.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[DllImport("ole32.dll")]
static extern int CoSetProxyBlanket([MarshalAs(UnmanagedType.IUnknown)]object pProxy, uint dwAuthnSvc, uint dwAuthzSvc,
	[MarshalAs(UnmanagedType.LPWStr)] string pServerPrincName, uint dwAuthnLevel, uint dwImpLevel, IntPtr pAuthInfo,
	uint dwCapabilities);

public enum RpcAuthnLevel
{
	Default = 0,
	None = 1,
	Connect = 2,
	Call = 3,
	Pkt = 4,
	PktIntegrity = 5,
	PktPrivacy = 6
}

public enum RpcImpLevel
{
	Default = 0,
	Anonymous = 1,
	Identify = 2,
	Impersonate = 3,
	Delegate = 4
}

public enum EoAuthnCap
{
	None = 0x00,
	MutualAuth = 0x01,
	StaticCloaking = 0x20,
	DynamicCloaking = 0x40,
	AnyAuthority = 0x80,
	MakeFullSIC = 0x100,
	Default = 0x800,
	SecureRefs = 0x02,
	AccessControl = 0x04,
	AppID = 0x08,
	Dynamic = 0x10,
	RequireFullSIC = 0x200,
	AutoImpersonate = 0x400,
	NoCustomMarshal = 0x2000,
	DisableAAA = 0x1000
}

[DllImport("ole32.dll")]
public static extern int CoInitializeSecurity(IntPtr pVoid, int cAuthSvc, IntPtr asAuthSvc, IntPtr pReserved1,
	RpcAuthnLevel level, RpcImpLevel impers, IntPtr pAuthList, EoAuthnCap dwCapabilities, IntPtr pReserved3);

static void Main(string[] args)
{
	var hres1 = CoSetProxyBlanket(null, 0, 0, null, 0, 0, IntPtr.Zero, 0); // Noncompliant

	var hres2 = CoInitializeSecurity(IntPtr.Zero, -1, IntPtr.Zero, IntPtr.Zero, RpcAuthnLevel.None,
		RpcImpLevel.Impersonate, IntPtr.Zero, EoAuthnCap.None, IntPtr.Zero); // Noncompliant
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1656</key>
    <type>BUG</type>
    <name>Variables should not be self-assigned</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake
and some other value or variable was intended for the assignment instead.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void SetName(string name)
{
  name = name;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public void SetName(string name)
{
  this.name = name;
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>3min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3449</key>
    <type>BUG</type>
    <name>Right operands of shift operators should be integers</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Numbers can be shifted with the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators, but the right operand of the operation needs to be an
<code>int</code> or a type that has an implicit conversion to <code>int</code>. However, with <code>dynamic</code>, the compiler's type checking is
turned off, so you can pass anything to a shift operator and have it compile. And if the argument can't be converted to <code>int</code> at runtime,
then a <code>RuntimeBinderException</code> will be raised.</p>
<h2>Noncompliant Code Example</h2>
<pre>
dynamic d = 5;
var x = d &gt;&gt; 5.4; // Noncompliant
x = d &gt;&gt; null; // Noncompliant
x &lt;&lt;= new object(); // Noncompliant
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1697</key>
    <type>BUG</type>
    <name>Short-circuit logic should be used to prevent null pointer dereferences in conditionals</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When either the equality operator in a null test or the logical operator that follows it is reversed, the code has the appearance of safely
null-testing the object before dereferencing it. Unfortunately the effect is just the opposite - the object is null-tested and then dereferenced
<em>only</em> if it is null, leading to a guaranteed null pointer dereference.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (str == null &amp;&amp; str.length() == 0) {
  System.out.println("String is empty");
}

if (str != null || str.length() &gt; 0) {
  System.out.println("String is not empty");
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (str == null || str.Length == 0)
{
  Console.WriteLine("String is empty");
}

if (str != null &amp;&amp; str.Length &gt; 0)
{
  Console.WriteLine("String is not empty");
}
</pre>
<h2>Deprecated</h2>
<p>This rule is deprecated; use {rule:csharpsquid:S2259} instead.</p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2437</key>
    <type>CODE_SMELL</type>
    <name>Silly bit operations should not be performed</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Certain bit operations are just silly and should not be performed because their results are predictable.</p>
<p>Specifically, using <code>&amp; -1</code> with any value will always result in the original value, as will <code>anyValue ^ 0</code> and
<code>anyValue | 0</code>.</p>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S122</key>
    <type>CODE_SMELL</type>
    <name>Statements should be on separate lines</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>For better readability, do not put more than one statement on a single line.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if(someCondition) DoSomething();
</pre>
<h2>Compliant Solution</h2>
<pre>
if(someCondition)
{
  DoSomething();
}
</pre>
<h2>Exceptions</h2>
<p>Anonymous functions containing a single statement are ignored. Block statements are not considered either.</p>
<pre>
Func&lt;object, bool&gt; item1 = o =&gt; { return true; }; // Compliant
Func&lt;object, bool&gt; item1 = o =&gt; { var r = false; return r; }; // Noncompliant
</pre>

]]></description>
    <tag>style</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2743</key>
    <type>CODE_SMELL</type>
    <name>Static fields should not be used in generic types</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A static field in a generic type is not shared among instances of different closed constructed types, thus
<code>LengthLimitedSingletonCollection&lt;int&gt;.instances</code> and <code>LengthLimitedSingletonCollection&lt;string&gt;.instances</code> will
point to different objects, even though <code>instances</code> is seemingly shared among all <code>LengthLimitedSingletonCollection&lt;&gt;</code>
generic classes.</p>
<p>If you need to have a static field shared among instances with different generic arguments, define a non-generic base class to store your static
members, then set your generic type to inherit from the base class.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class LengthLimitedSingletonCollection&lt;T&gt; where T : new()
{
  protected const int MaxAllowedLength = 5;
  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); // Noncompliant

  public static T GetInstance()
  {
    object instance;

    if (!instances.TryGetValue(typeof(T), out instance))
    {
      if (instances.Count &gt;= MaxAllowedLength)
      {
        throw new Exception();
      }
      instance = new T();
      instances.Add(typeof(T), instance);
    }
    return (T)instance;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class SingletonCollectionBase
{
  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;();
}

public class LengthLimitedSingletonCollection&lt;T&gt; : SingletonCollectionBase where T : new()
{
  protected const int MaxAllowedLength = 5;

  public static T GetInstance()
  {
    object instance;

    if (!instances.TryGetValue(typeof(T), out instance))
    {
      if (instances.Count &gt;= MaxAllowedLength)
      {
        throw new Exception();
      }
      instance = new T();
      instances.Add(typeof(T), instance);
    }
    return (T)instance;
  }
}
</pre>
<h2>Exceptions</h2>
<p>If the static field or property uses a type parameter, then the developer is assumed to understand that the static member is not shared among the
closed constructed types.</p>
<pre>
public class Cache&lt;T&gt;
{
   private static Dictionary&lt;string, T&gt; CacheDictionary { get; set; } // Compliant
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3263</key>
    <type>BUG</type>
    <name>Static fields should appear in the order they must be initialized </name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class
above the field or fields required for its initialization will yield unexpected results.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  public static int X = Y; // Noncompliant; Y at this time is still assigned default(int), i.e. 0
  public static int Y = 42;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass
{
  public static int Y = 42;
  public static int X = Y;
}
</pre>
<p>or</p>
<pre>
class MyClass
{
  public static int X;
  public static int Y = 42;

  static MyClass()
  {
    X = Y;
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2223</key>
    <type>CODE_SMELL</type>
    <name>Non-constant static fields should not be visible</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A <code>static</code> field that is neither constant nor read-only is not thread-safe. Correctly accessing these fields from different threads
needs synchronization with <code>lock</code>s. Improper synchronization may lead to unexpected results, thus publicly visible static fields are best
suited for storing non-changing data shared by many consumers. To enforce this intent, these fields should be marked <code>readonly</code> or
converted to constants.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Math
{
  public static double Pi = 3.14;  // Noncompliant
}
</pre>
<p>or</p>
<pre>
public class Shape
{
  public static Shape Empty = new EmptyShape();  // Noncompliant

  private class EmptyShape : Shape
  {
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Math
{
  public const double Pi = 3.14;
}
</pre>
<p>or</p>
<pre>
public class Shape
{
  public static readonly Shape Empty = new EmptyShape();

  private class EmptyShape : Shape
  {
  }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3010</key>
    <type>BUG</type>
    <name>Static fields should not be updated in constructors</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Assigning a value to a <code>static</code> field in a constructor could cause unreliable behavior at runtime since it will change the value for all
instances of the class.</p>
<p>Instead remove the field's <code>static</code> modifier, or initialize it statically.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Person
{
  private static DateTime dateOfBirth;
  private static int expectedFingers;

  public Person(DateTime birthday)
  {
    dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday
    expectedFingers = 10;  // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Person
{
  private DateTime dateOfBirth;
  private static int expectedFingers = 10;

  public Person(DateTime birthday)
  {
    this.dateOfBirth = birthday;
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2696</key>
    <type>CODE_SMELL</type>
    <name>Instance members should not write to "static" fields</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Correctly updating a <code>static</code> field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple
class instances and/or multiple threads in play. </p>
<p>This rule raises an issue each time a <code>static</code> field is updated from a non-static method or property.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  private static int count = 0;

  public void DoSomething()
  {
    //...
    count++;  // Noncompliant
  }
}
</pre>

]]></description>
    <tag>multi-threading</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2156</key>
    <type>CODE_SMELL</type>
    <name>"sealed" classes should not have "protected" members</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The difference between <code>private</code> and <code>protected</code> visibility is that child classes can see and use <code>protected</code>
members, but they cannot see <code>private</code> ones. Since a <code>sealed</code> class cannot have children, marking its members
<code>protected</code> is confusingly pointless.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public sealed class MySealedClass
{
    protected string name = "Fred";  // Noncompliant
    protected void SetName(string name) // Noncompliant
    {
        // ...
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public sealed class MySealedClass
{
    private string name = "Fred";
    public void SetName(string name)
    {
        // ...
    }
}
</pre>

]]></description>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2674</key>
    <type>BUG</type>
    <name>The length returned from a stream read should be checked</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>You cannot assume that any given stream reading call will fill the <code>byte[]</code> passed in to the method with the number of bytes requested.
Instead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both
harmful and difficult to reproduce.</p>
<p>This rule raises an issue when a <code>Stream.Read</code> or a <code>Stream.ReadAsync</code> method is called, but the return value is not
checked.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void DoSomething(string fileName)
{
  using (var stream = File.Open(fileName, FileMode.Open))
  {
    var result = new byte[stream.Length];
    stream.Read(result, 0, (int)stream.Length); // Noncompliant
    // ... do something with result
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public void DoSomething(string fileName)
{
  using (var stream = File.Open(fileName, FileMode.Open))
  {
    var buffer = new byte[1024];
    using (var ms = new MemoryStream())
    {
        int read;
        while ((read = stream.Read(buffer, 0, buffer.Length)) &gt; 0)
        {
            ms.Write(buffer, 0, read);
        }
        // ... do something with ms
    }
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/XACSAQ">CERT, FIO10-J.</a> - Ensure the array is filled when using read() to fill an
  array </li>
</ul>

]]></description>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1643</key>
    <type>CODE_SMELL</type>
    <name>Strings should not be concatenated using '+' in a loop</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>StringBuilder</code> is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.</p>
<h2>Noncompliant Code Example</h2>
<pre>
string str = "";
for (int i = 0; i &lt; arrayOfStrings.Length ; ++i)
{
  str = str + arrayOfStrings[i];
}
</pre>
<h2>Compliant Solution</h2>
<pre>
StringBuilder bld = new StringBuilder();
for (int i = 0; i &lt; arrayOfStrings.Length; ++i)
{
  bld.Append(arrayOfStrings[i]);
}
string str = bld.ToString();
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2275</key>
    <type>BUG</type>
    <name>Composite format strings should not lead to unexpected behavior at runtime</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected
behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of
<code>String.Format</code>, <code>StringBuilder.AppendFormat</code>, <code>Console.Write</code>, <code>Console.WriteLine</code>,
<code>TextWriter.Write</code>, <code>TextWriter.WriteLine</code>, <code>Debug.WriteLine(String, Object[])</code>,
<code>Trace.TraceError(String, Object[])</code>, <code>Trace.TraceInformation(String, Object[])</code>,
<code>Trace.TraceWarning(String, Object[])</code> and <code>TraceSource.TraceInformation(String, Object[])</code>. </p>
<h2>Noncompliant Code Example</h2>
<pre>
s = string.Format("[0}", arg0);
s = string.Format("{{0}", arg0);
s = string.Format("{0}}", arg0);
s = string.Format("{-1}", arg0);
s = string.Format("{0} {1}", arg0);
</pre>
<h2>Compliant Solution</h2>
<pre>
s = string.Format("{0}", 42); // Compliant
s = string.Format("{0,10}", 42); // Compliant
s = string.Format("{0,-10}", 42); // Compliant
s = string.Format("{0:0000}", 42); // Compliant
s = string.Format("{2}-{0}-{1}", 1, 2, 3); // Compliant
s = string.Format("no format"); // Compliant
</pre>
<h2>Exceptions</h2>
<ul>
  <li> No issue is raised if the format string is not a <code>const</code>. </li>
</ul>
<pre>
var pattern = "{0} {1} {2}";
var res = string.Format(pattern, 1, 2); // Compliant, not const string are not recognized
</pre>
<ul>
  <li> No issue is raised if the argument is not an inline creation array. </li>
</ul>
<pre>
var array = new int[] {};
var res = string.Format("{0} {1}", array); // Compliant we don't know the size of the array
</pre>
<ul>
  <li> This rule doesn't check whether the format specifier (defined after the <code>:</code>) is actually valid. </li>
</ul>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/wQA1">CERT, FIO47-C.</a> - Use valid format strings </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/e4EyAQ">CERT, FIO00-CPP.</a> - Take care when creating format strings </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3457</key>
    <type>CODE_SMELL</type>
    <name>Composite format strings should be used correctly</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected
behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of
<code>String.Format</code>, <code>StringBuilder.AppendFormat</code>, <code>Console.Write</code>, <code>Console.WriteLine</code>,
<code>TextWriter.Write</code>, <code>TextWriter.WriteLine</code>, <code>Debug.WriteLine(String, Object[])</code>,
<code>Trace.TraceError(String, Object[])</code>, <code>Trace.TraceInformation(String, Object[])</code>,
<code>Trace.TraceWarning(String, Object[])</code> and <code>TraceSource.TraceInformation(String, Object[])</code>. </p>
<h2>Noncompliant Code Example</h2>
<pre>
s = string.Format("{0}", arg0, arg1); // Noncompliant, arg1 is declared but not used.
s = string.Format("{0} {2}", arg0, arg1, arg2); // Noncompliant, the format item with index 1 is missing so arg1 will not be used.
s = string.Format("foo"); // Noncompliant, there is no need to use string.Format here.
</pre>
<h2>Compliant Solution</h2>
<pre>
s = string.Format("{0}", arg0);
s = string.Format("{0} {1}", arg0, arg2);
s = "foo";
</pre>
<h2>Exceptions</h2>
<ul>
  <li> No issue is raised if the format string is not a <code>const</code>. </li>
</ul>
<pre>
var pattern = "{0} {1} {2}";
var res = string.Format(pattern, 1, 2); // Compliant, not const string are not recognized
</pre>
<ul>
  <li> No issue is raised if the argument is not an inline creation array. </li>
</ul>
<pre>
var array = new int[] {};
var res = string.Format("{0} {1}", array); // Compliant we don't know the size of the array
</pre>
<ul>
  <li> This rule doesn't check whether the format specifier (defined after the <code>:</code>) is actually valid. </li>
</ul>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/wQA1">CERT, FIO47-C.</a> - Use valid format strings </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/e4EyAQ">CERT, FIO00-CPP.</a> - Take care when creating format strings </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1449</key>
    <type>BUG</type>
    <name>Culture should be specified for "string" operations</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>string.ToLower()</code>, <code>ToUpper</code>, <code>IndexOf</code>, <code>LastIndexOf</code>, and <code>Compare</code> are all
culture-dependent, as are some (floating point number and <code>DateTime</code>-related) calls to <code>ToString</code>. Fortunately, all have
variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default
culture, possibly creating problems with international characters.</p>
<p><code>string.CompareTo()</code> is also culture specific, but has no overload that takes a culture information, so instead it's better to use
<code>CompareOrdinal</code>, or <code>Compare</code> with culture.</p>
<p>Calls without a culture may work fine in the system's "home" environment, but break in ways that are extremely difficult to diagnose for customers
who use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it's time to fix them.</p>
<h2>Noncompliant Code Example</h2>
<pre>
var lowered = someString.ToLower(); //Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
var lowered = someString.ToLower(CultureInfo.InvariantCulture);
</pre>
<p>or</p>
<pre>
var lowered = someString.ToLowerInvariant();
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/EwAiAg">CERT, STR02-J.</a> - Specify an appropriate locale when comparing
  locale-dependent data </li>
</ul>

]]></description>
    <tag>unpredictable</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3876</key>
    <type>CODE_SMELL</type>
    <name>Strings or integral types should be used for indexers</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and
potentially a situation where a method should be used instead.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public int this[MyCustomClass index]  // Noncompliant
{
    // get and set accessors
}
</pre>

]]></description>
    <tag>design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3234</key>
    <type>CODE_SMELL</type>
    <name>"GC.SuppressFinalize" should not be invoked for types without destructors</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>GC.SuppressFinalize</code> asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the
dispose pattern where object finalization is already handled in <code>IDisposable.Dispose</code>. However, it has no effect if there is no finalizer
defined in the object's type, so using it in such cases is just confusing.</p>
<p>This rule raises an issue when <code>GC.SuppressFinalize</code> is called for objects of <code>sealed</code> types without a finalizer.</p>
<p><strong></strong>Note:** {rule:csharpsquid:S3971} is a stricter version of this rule. Typically it makes sense to activate only one of these 2
rules.</p>
<h2>Noncompliant Code Example</h2>
<pre>
sealed class MyClass
{
  public void Method()
  {
    ...
    GC.SuppressFinalize(this); //Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
sealed class MyClass
{
  public void Method()
  {
    ...
  }
}
</pre>

]]></description>
    <tag>unused</tag>
    <tag>confusing</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3458</key>
    <type>CODE_SMELL</type>
    <name>Empty "case" clauses that fall through to the "default" should be omitted</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Empty <code>case</code> clauses that fall through to the default are useless. Whether or not such a <code>case</code> is present, the
<code>default</code> clause will be invoked. Such <code>case</code>s simply clutter the code, and should be removed.</p>
<h2>Noncompliant Code Example</h2>
<pre>
switch(ch)
{
  case 'a' :
    HandleA();
    break;
  case 'b' :
    HandleB();
    break;
  case 'c' :  // Noncompliant
  default:
    HandleTheRest();
    break;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
switch(ch)
{
  case 'a' :
    HandleA();
    break;
  case 'b' :
    HandleB();
    break;
  default:
    HandleTheRest();
    break;
}
</pre>

]]></description>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1301</key>
    <type>CODE_SMELL</type>
    <name>"switch" statements should have at least 3 "case" clauses</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.</p>
<p>For just one or two cases however, the code will be more readable with <code>if</code> statements.</p>
<h2>Noncompliant Code Example</h2>
<pre>
switch (variable)
{
  case 0:
    doSomething();
    break;
  default:
    doSomethingElse();
    break;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (variable == 0)
{
  doSomething();
}
else
{
  doSomethingElse();
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause. </li>
  <li> MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause. </li>
  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>bad-practice</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3532</key>
    <type>CODE_SMELL</type>
    <name>Empty "default" clauses should be removed</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>default</code> clause should take appropriate action. Having an empty <code>default</code> is a waste of keystrokes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
enum Fruit
{
  Apple,
  Orange,
  Banana
}

void PrintName(Fruit fruit)
{
  switch(fruit)
  {
    case Fruit.Apple:
      Console.WriteLine("apple");
      break;
    default:  //Noncompliant
      break;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
enum Fruit
{
  Apple,
  Orange,
  Banana
}

void PrintName(Fruit fruit)
{
  switch(fruit)
  {
    case Fruit.Apple:
      Console.WriteLine("apple");
      break;
    default:
      throw new NotSupportedException();
  }
}
</pre>
<p>or</p>
<pre>
void PrintName(Fruit fruit)
{
  switch(fruit)
  {
    case Fruit.Apple:
      Console.WriteLine("apple");
      break;
  }
}
</pre>

]]></description>
    <tag>unused</tag>
    <tag>finding</tag>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>	1min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S131</key>
    <type>CODE_SMELL</type>
    <name>"switch/Select" statements should end with "default/Case Else" clauses</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The requirement for a final <code>default</code> clause is defensive programming. The clause should either take appropriate action, or contain a
suitable comment as to why no action is taken. Even when the <code>switch</code> covers all current values of an <code>enum</code>, a
<code>default</code> case should still be used because there is no guarantee that the <code>enum</code> won't be extended.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int foo = 42;
switch (foo) // Noncompliant
{
  case 0:
    Console.WriteLine("foo = 0");
    break;
  case 42:
    Console.WriteLine("foo = 42");
    break;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int foo = 42;
switch (foo) // Compliant
{
  case 0:
    Console.WriteLine("foo = 0");
    break;
  case 42:
    Console.WriteLine("foo = 42");
    break;
  default:
    throw new InvalidOperationException("Unexpected value foo = " + foo);
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>
  <li> MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause </li>
  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>
  <li> MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause </li>
  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>
  <li> MISRA C:2012, 16.4 - Every <em>switch</em> statement shall have a <em>default</em> label </li>
  <li> MISRA C:2012, 16.5 - A <em>default</em> label shall appear as either the first or the last <em>switch label</em> of a <em>switch</em> statement
  </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/478.html">MITRE, CWE-478</a> - Missing Default Case in Switch Statement </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/YgE">CERT, MSC01-C.</a> - Strive for logical completeness </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/JoIyAQ">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>misra</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S105</key>
    <type>CODE_SMELL</type>
    <name>Tabulation characters should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</p>
<p>So the use of the tabulation character must be banned.</p>

]]></description>
    <tag>convention</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3216</key>
    <type>CODE_SMELL</type>
    <name>"ConfigureAwait(false)" should be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>After an <code>await</code>ed <code>Task</code> has executed, you can continue execution in the original, calling thread or any arbitrary thread.
Unless the rest of the code needs the context from which the <code>Task</code> was spawned, <code>Task.ConfigureAwait(false)</code> should be used to
keep execution in the <code>Task</code> thread to avoid the need for context switching and the possibility of deadlocks.</p>
<p>This rule raises an issue when code in a class library <code>await</code>s a <code>Task</code> and continues execution in the original calling
thread.</p>
<h2>Noncompliant Code Example</h2>
<pre>
var response = await httpClient.GetAsync(url);  // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
var response = await httpClient.GetAsync(url).ConfigureAwait(false);
</pre>

]]></description>
    <tag>multi-threading</tag>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2758</key>
    <type>BUG</type>
    <name>The ternary operator should not return the same value regardless of the condition</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When the second and third operands of a ternary operator are the same, the operator will always return the same value regardless of the condition.
Either the operator itself is pointless, or a mistake was made in coding it. </p>
<h2>Noncompliant Code Example</h2>
<pre>
public bool CanVote(Person person)
{
  return person.GetAge() &gt; 18 ? true : true; // Noncompliant; is this what was intended?
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public bool CanVote(Person person)
{
  return person.GetAge() &gt; 18 ? true : false;
  // or even better:
  // return person.GetAge() &gt; 18;
}
</pre>
<h2>Deprecated</h2>
<p>This rule is deprecated; use {rule:csharpsquid:S1871} instead.</p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3005</key>
    <type>BUG</type>
    <name>"ThreadStatic" should not be used on non-static fields</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When a non-<code>static</code> class field is annotated with <code>ThreadStatic</code>, the code seems to show that the field can have different
values for different calling threads, but that's not the case, since the <code>ThreadStatic</code> attribute is simply ignored on
non-<code>static</code> fields. </p>
<p>So <code>ThreadStatic</code> should either be removed or replaced with a use of the <code>ThreadLocal&lt;T&gt;</code> class, which gives a similar
behavior for non-<code>static</code> fields.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  [ThreadStatic]  // Noncompliant
  private int count = 0;

  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MyClass
{
  private int count = 0;

  // ...
}
</pre>
<p>or</p>
<pre>
public class MyClass
{
  private readonly ThreadLocal&lt;int&gt; count = new ThreadLocal&lt;int&gt;();
  public int Count
  {
    get { return count.Value; }
    set { count.Value = value; }
  }
  // ...
}
</pre>

]]></description>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2996</key>
    <type>BUG</type>
    <name>"ThreadStatic" fields should not be initialized</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When an object has a field annotated with <code>ThreadStatic</code>, that field is shared within a given thread, but unique across threads. Since a
class' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial
values.</p>
<p>Instead, allow such fields to be initialized to their default values or make the initialization lazy.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
  [ThreadStatic]
  public static object PerThreadObject = new object(); // Noncompliant. Will be null in all the threads except the first one.
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo
{
  [ThreadStatic]
  public static object _perThreadObject;
  public static object PerThreadObject
  {
    get
    {
      if (_perThreadObject == null)
      {
        _perThreadObject = new object();
      }
      return _perThreadObject;
    }
  }
}
</pre>

]]></description>
    <tag>multi-threading</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S112</key>
    <type>CODE_SMELL</type>
    <name>General exceptions should never be thrown</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Throwing such general exceptions as <code>Exception</code>, <code>SystemException</code>, <code>ApplicationException</code>,
<code>IndexOutOfRangeException</code>, <code>NullReferenceException</code>, <code>OutOfMemoryException</code> and
<code>ExecutionEngineException</code> prevents calling methods from handling true, system-generated exceptions differently than application-generated
errors. </p>
<h2>Noncompliant Code Example</h2>
<pre>
public void DoSomething(object obj)
{
  if (obj == null)
  {
    throw new NullReferenceException("obj");  // Noncompliant
  }
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public void DoSomething(object obj)
{
  if (obj == null)
  {
    throw new ArgumentNullException("obj");
  }
  // ...
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/397.html">MITRE, CWE-397</a> - Declaration of Throws for Generic Exception </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/BoB3AQ">CERT, ERR07-J.</a> - Do not throw RuntimeException, Exception, or Throwable
  </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <tag>error-handling</tag>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2436</key>
    <type>CODE_SMELL</type>
    <name>Classes and methods should not have too many generic parameters</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A method or class with too many type parameters has likely aggregated too many responsibilities and should be split.</p>
<h2>Noncompliant Code Example</h2>
<p>With the default parameter value of 2:</p>
<pre>
&lt;S, T, U, V&gt; void foo() {} // Noncompliant; not really readable
&lt;String, Integer, Object, String&gt;foo(); // especially on invocations
</pre>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>max</key>
      <description><![CDATA[Maximum authorized number of generic parameters.]]></description>
      <type>INTEGER</type>
      <defaultValue>2</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1479</key>
    <type>CODE_SMELL</type>
    <name>"switch" statements should not have too many "case" clauses</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When <code>switch</code> statements have large sets of <code>case</code> clauses, it is usually an attempt to map two sets of data. A real map
structure would be more readable and maintainable, and should be used instead.</p>
<h2>Exceptions</h2>
<p>This rule ignores <code>switch</code>es over <code>Enum</code>s and empty, fall-through cases.</p>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>maximum</key>
      <description><![CDATA[Maximum number of case]]></description>
      <type>INTEGER</type>
      <defaultValue>30</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S107</key>
    <type>CODE_SMELL</type>
    <name>Methods should not have too many parameters</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many
things.</p>
<h2>Noncompliant Code Example</h2>
<p>With a maximum number of 4 parameters:</p>
<pre>
public void doSomething(int param1, int param2, int param3, string param4, long param5)
{
...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public void doSomething(int param1, int param2, int param3, string param4)
{
...
}
</pre>

]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>max</key>
      <description><![CDATA[Maximum authorized number of parameters]]></description>
      <type>INTEGER</type>
      <defaultValue>7</defaultValue>
    </param>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2225</key>
    <type>BUG</type>
    <name>"ToString()" method should not return null</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Calling <code>ToString()</code> on an object should always return a string. Returning <code>null</code> instead contravenes the method's implicit
contract.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public override string ToString ()
{
  if (this.collection.Count == 0)
  {
    return null; // Noncompliant
  }
  else
  {
    // ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public override string ToString ()
{
  if (this.collection.Count == 0)
  {
    return string.Empty;
  }
  else
  {
    // ...
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/476.html">MITRE CWE-476</a> - NULL Pointer Dereference </li>
</ul>

]]></description>
    <tag>cwe</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3443</key>
    <type>CODE_SMELL</type>
    <name>Type should not be examined on "System.Type" instances</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>If you call <code>GetType()</code> on a <code>Type</code> variable, the return value will always be <code>typeof(System.Type)</code>. So there's no
real point in making that call. The same applies to passing a type argument to <code>IsInstanceOfType</code>. In both cases the results are entirely
predictable.</p>
<h2>Noncompliant Code Example</h2>
<pre>
var type = typeof(int);
var ttype = type.GetType(); //Noncompliant, always typeof(System.Type)

var s = "abc";

if (s.GetType().IsInstanceOfType(typeof(string))) //Noncompliant; false
{ /* ... */ }
</pre>
<h2>Compliant Solution</h2>
<pre>
var s = "abc";

if (s.GetType().IsInstanceOfType("ssss"))
{ /* ... */ }
</pre>

]]></description>
    <tag>suspicious</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2761</key>
    <type>BUG</type>
    <name>Doubled prefix operators "!!" and "~~" should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Calling the <code>!</code> or <code>~</code> prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are
typically caused by accidentally double-tapping the key in question without noticing.</p>
<p>Either this is a bug, if the operator was actually meant to be called once, or misleading if done on purpose.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int v1 = 0;
bool v2 = false;

var v3 = !!v1; // Noncompliant
var v4 = ~~v2; // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
int v1 = 0;
bool v2 = false;

var v3 = !v1;
var v4 = ~v2;
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1751</key>
    <type>BUG</type>
    <name>Jump statements should not be used unconditionally</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Having an unconditional <code>break</code>, <code>return</code>, <code>(@)throw</code> or <code>goto</code> in a loop renders it useless; the loop
will only execute once and the loop structure itself is simply wasted keystrokes.</p>
<p>Having an unconditional <code>continue</code> in a loop can render the loop meaningless, or is itself wasted keystrokes, depending on where in the
loop it occurs.</p>
<p>Having an unconditional <code>return</code> anywhere other than at the end of a function or method simply renders all the rest of the code in the
method useless.</p>
<p>For these reasons, unconditional jump statements should never be used except for the final <code>return</code> in a function or method.</p>
<h2>Noncompliant Code Example</h2>
<pre>
for (var i = 0; i &lt; 10; i++)
{
    Console.WriteLine(i);
    break;  // loop only executes once
}

for (var i = 0; i &lt; 10; i++)
{
    continue;
    Console.WriteLine(i); // this is never executed
}

for (var i = 0; i &lt; 10; i++)
{
    Console.WriteLine(i);
    continue;  // this is meaningless; the loop would continue anyway
}
</pre>
<h2>Compliant Solution</h2>
<pre>
for (var i = 0; i &lt; 10; i++)
{
    Console.WriteLine(i);
}

for (var i = 0; i &lt; 10; i++)
{
    Console.WriteLine(i);
    if (ErrorOccurred())
    {
        break;
    }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. </li>
  <li> MISRA C++:2008, 0-1-1 - A <em>project</em> shall not contain <em>unreachable code</em>. </li>
  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. </li>
  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
  executed </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3264</key>
    <type>CODE_SMELL</type>
    <name>Events should be invoked</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Events that are not invoked anywhere are dead code, and there's no good reason to keep them in the source.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class UninvokedEventSample
{
    private event Action&lt;object, EventArgs&gt; Happened; //Noncompliant

    public void RegisterEventHandler(Action&lt;object, EventArgs&gt; handler)
    {
        Happened += handler; //we register some event handlers
    }

    public void RaiseEvent()
    {
        if (Happened != null)
        {
            // Happened(this, null); // the event is never triggered, because this line is commented out.
        }
    }
}
</pre>

]]></description>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1144</key>
    <type>CODE_SMELL</type>
    <name>Unused private types or members should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p><code>private</code> or <code>internal</code> types or <code>private</code> members that are never executed or referenced are dead code:
unnecessary, inoperative code that should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it easier to
understand the program and preventing bugs from being introduced.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
  private void UnusedPrivateMethod() {...} // Noncompliant

  private class UnusedClass {...} // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo
{
  private Foo()
  {
    UsedPrivateMethod();
  }

  private void UsedPrivateMethod()
  {
    var c = new UsedClass();
  }

  private class UsedClass {...}
}
</pre>
<h2>Exceptions</h2>
<p>This rule doesn't raise any issue on:</p>
<ul>
  <li> Empty constructors </li>
  <li> Attributed members </li>
  <li> Empty serialization constructor on type with <code>System.SerializableAttribute</code> attribute. </li>
  <li> Internals in assemblies that have a <code>System.Runtime.CompilerServices.InternalsVisibleToAttribute</code> attribute. </li>
</ul>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/OYIyAQ">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3241</key>
    <type>CODE_SMELL</type>
    <name>Methods should not return values that are never used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their
callers, then clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity. </p>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
</ul>

]]></description>
    <tag>design</tag>
    <tag>cert</tag>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3962</key>
    <type>CODE_SMELL</type>
    <name>"static readonly" constants should be "const" instead</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The value of a <code>static readonly</code> field is computed at runtime while the value of a <code>const</code> field is calculated at compile
time, which improves performance.</p>
<p>This rule raises an issue when a <code>static readonly</code> field is initialiazed with a value that is computable at compile time.</p>
<p>As specified by Microsoft, the list of types that can have a constant value are:</p>
<table>
  <tbody>
    <tr>
      <th>C# type</th>
      <th>.Net Fwk type</th>
    </tr>
    <tr>
      <td>bool</td>
      <td>System.Boolean</td>
    </tr>
    <tr>
      <td>byte</td>
      <td>System.Byte</td>
    </tr>
    <tr>
      <td>sbyte</td>
      <td>System.SByte</td>
    </tr>
    <tr>
      <td>char</td>
      <td>System.Char</td>
    </tr>
    <tr>
      <td>decimal</td>
      <td>System.Decimal</td>
    </tr>
    <tr>
      <td>double</td>
      <td>System.Double</td>
    </tr>
    <tr>
      <td>float</td>
      <td>System.Single</td>
    </tr>
    <tr>
      <td>int</td>
      <td>System.Int32</td>
    </tr>
    <tr>
      <td>uint</td>
      <td>System.UInt32</td>
    </tr>
    <tr>
      <td>long</td>
      <td>System.Int64</td>
    </tr>
    <tr>
      <td>ulong</td>
      <td>System.UInt64</td>
    </tr>
    <tr>
      <td>short</td>
      <td>System.Int16</td>
    </tr>
    <tr>
      <td>ushort</td>
      <td>System.UInt16</td>
    </tr>
    <tr>
      <td>string</td>
      <td>System.String</td>
    </tr>
  </tbody>
</table>
<h2>Noncompliant Code Example</h2>
<pre>
namespace myLib
{
  public class Foo
  {
    static readonly int x = 1;  // Noncompliant
    static readonly int y = x + 4; // Noncompliant
    static readonly string s = "Bar";  // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
namespace myLib
{
  public class Foo
  {
    const int x = 1;
    const int y = x + 4;
    const string s = "Bar";
  }
}
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S121</key>
    <type>CODE_SMELL</type>
    <name>Control structures should use curly braces</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.</p>
<h2>Noncompliant Code Example</h2>
<pre>
// the two statements seems to be attached to the if statement, but that is only true for the first one:
if (condition)
  ExecuteSomething();
  CheckSomething();
</pre>
<h2>Compliant Solution</h2>
<pre>
if (condition)
{
  ExecuteSomething();
  CheckSomething();
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>
  <li> MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a
  compound statement, or another if statement </li>
  <li> MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>
  <li> MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a
  compound statement, or another if statement </li>
  <li> MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/1QGMAg">CERT, EXP19-C.</a> - Use braces for the body of an if, for, or while statement
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/3wHEAw">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement
  </li>
</ul>

]]></description>
    <tag>misra</tag>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3908</key>
    <type>CODE_SMELL</type>
    <name>Generic event handlers should be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Since .Net Framework version 2.0 it is not necessary to declare a delegate that specifies a class derived from <code>System.EventArgs</code>. The
<code>System.EventHandler&lt;TEventArgs&gt;</code> delegate mechanism should be used instead as it allows any class derived from
<code>EventArgs</code> to be used with that handler.</p>
<p>This rule raises an issue when an old style delegate is used as an event handler.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MyEventArgs : EventArgs
{
}

public delegate void MyEventHandler(object sender, MyEventArgs e); // Noncompliant

public class EventProducer
{
  public event MyEventHandler MyEvent;

  protected virtual void OnMyEvent(MyEventArgs e)
  {
    if (MyEvent != null)
    {
      MyEvent(e);
    }
  }
}

public class EventConsumer
{
  public EventConsumer(EventProducer producer)
  {
      producer.MyEvent += HandleEvent;
  }

  private void HandleEvent(object sender, MyEventArgs e)
  {
    // Do something...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class MyEventArgs : EventArgs
{
}

public class EventProducer
{
  public event EventHandler&lt;MyEventArgs&gt; MyEvent;

  protected virtual void OnMyEvent(MyEventArgs e)
  {
    if (MyEvent != null)
    {
      MyEvent(e);
    }
  }
}

public class EventConsumer
{
  public EventConsumer(EventProducer producer)
  {
      producer.MyEvent += HandleEvent;
  }

  private void HandleEvent(object sender, MyEventArgs e)
  {
    // Do something...
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2178</key>
    <type>CODE_SMELL</type>
    <name>Short-circuit logic should be used in boolean contexts</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The use of non-short-circuit logic in a boolean context is likely a mistake - one that could cause serious program errors as conditions are
evaluated under the wrong circumstances.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (GetTrue() | GetFalse()) // Noncompliant; both sides evaluated
{
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (GetTrue() || GetFalse()) // true short-circuit logic
{
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/g4FtAg">CERT, EXP46-C.</a> - Do not use a bitwise operator with a Boolean-like operand
  </li>
</ul>

]]></description>
    <tag>cert</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3256</key>
    <type>CODE_SMELL</type>
    <name>"string.IsNullOrEmpty" should be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Using <code>string.Equals</code> to determine if a string is empty is significantly slower than using <code>string.IsNullOrEmpty()</code> or
checking for <code>string.Length == 0</code>. <code>string.IsNullOrEmpty()</code> is both clear and concise, and therefore preferred to laborious,
error-prone, manual null- and emptiness-checking.</p>
<h2>Noncompliant Code Example</h2>
<pre>
"".Equals(name); // Noncompliant
!name.Equals(""); // Noncompliant
name.Equals(string.Empty); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
name != null &amp;&amp; name.Length &gt; 0 // Compliant but more error prone
!string.IsNullOrEmpty(name)
string.IsNullOrEmpty(name)
</pre>

]]></description>
    <tag>clumsy</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3994</key>
    <type>CODE_SMELL</type>
    <name>URI Parameters should not be strings</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The <code>System.Uri</code>
class is a safe alternative and should be preferred. At minimum, an overload of the method taking a <code>System.Uri</code> as a parameter should be
provided in each class that contains a method with an apparent Uri passed as a <code>string</code>.</p>
<p>This rule raises issues when a method has a string parameter with a name containing "uri", "Uri", "urn", "Urn", "url" or "Url", and the type
doesn't declare a corresponding overload taking an <code>System.Uri</code> parameter instead.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {

      public void FetchResource(string uriString) { } // Noncompliant
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {

      public void FetchResource(string uriString)
      {
          FetchResource(new Uri(uriString));
      }

      public void FetchResource(Uri uri) { }
   }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3995</key>
    <type>CODE_SMELL</type>
    <name>URI return values should not be strings</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The <code>System.Uri</code>
class is a safe alternative and should be preferred.</p>
<p>This rule raises an issue when a method has a <code>string</code> return type and its name contains "Uri", "Urn", or "Url" or begins with "uri",
"urn", or "url".</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {
      public string GetParentUri() // Noncompliant
      {
         return "http://www.mysite.com";
      }
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {

      public Uri GetParentUri()
      {
         return new URI("http://www.mysite.com");
      }
   }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3996</key>
    <type>CODE_SMELL</type>
    <name>URI properties should not be strings</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The <code>System.Uri</code>
class is a safe alternative and should be preferred.</p>
<p>This rule raises an issue when a property is a string type and its name contains "uri", "Uri", "urn", "Urn", "url" or "Url".</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {
      string myUri;

      public string MyUri // Noncompliant
      {
         get { return myURI; }
         set { myUri = value; }
      }
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {
      Uri myUri;

      public Uri MyUri
      {
         get { return myURI; }
         set { myUri = value; }
      }
   }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3997</key>
    <type>CODE_SMELL</type>
    <name>String URI overloads should call "System.Uri" overloads</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The <code>System.Uri</code>
class is a safe alternative and should be preferred.</p>
<p>This rule raises an issue when two overloads differ only by the string / <code>Uri</code> parameter and the string overload doesn't call the
<code>Uri</code> overload. It is assumed that the string parameter represents a URI because of the exact match besides that parameter type. It stands
to reason that the safer overload should be used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {
      public void FetchResource(string uriString) // Noncompliant
      {
         // No calls to FetResource(Uri)
      }

      public void FetchResource(Uri uri) { }
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
   public class MyClass
   {
      public void FetchResource(string uriString)
      {
          FetchResource(new Uri(uriString));
      }

      public void FetchResource(Uri uri) { }
   }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S4005</key>
    <type>CODE_SMELL</type>
    <name>"System.Uri" arguments should be used instead of strings</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The <code>System.Uri</code>
class is a safe alternative and should be preferred.</p>
<p>This rule raises an issue when a called method has a string parameter with a name containing "uri", "Uri", "urn", "Urn", "url" or "Url" and the
declaring type contains a corresponding overload that takes a <code>System.Uri</code> as a parameter.</p>
<p>When there is a choice between two overloads that differ only regarding the representation of a URI, the user should choose the overload that takes
a <code>System.Uri</code> argument.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace MyLibrary
{
   public class Foo
   {
      public void FetchResource(string uriString) { }
      public void FetchResource(Uri uri) { }

      public string ReadResource(string uriString, string name, bool isLocal) { }
      public string ReadResource(Uri uri, string name, bool isLocal) { }

      public void Main() {
        FetchResource("http://www.mysite.com"); // Noncompliant
        ReadResource("http://www.mysite.com", "foo-resource", true); // Noncompliant
      }
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace MyLibrary
{
   public class Foo
   {
      public void FetchResource(string uriString) { }
      public void FetchResource(Uri uri) { }

      public string ReadResource(string uriString, string name, bool isLocal) { }
      public string ReadResource(Uri uri, string name, bool isLocal) { }

      public void Main() {
        FetchResource(new Uri("http://www.mysite.com"));
        ReadResource(new Uri("http://www.mysite.com"), "foo-resource", true);
      }
   }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3237</key>
    <type>CODE_SMELL</type>
    <name>"value" parameters should be used</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>In property and indexer <code>set</code> methods, and in event <code>add</code> and <code>remove</code> methods, the implicit <code>value</code>
parameter holds the value the accessor was called with. Not using the <code>value</code> means that the accessor ignores the caller's intent which
could cause unexpected results at runtime.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private int count;
public int Count
{
  get { return count; }
  set { count = 42; } // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
private int count;
public int Count
{
  get { return count; }
  set { count = value; }
}
</pre>
<p>or</p>
<pre>
public int Count
{
  get { return count; }
  set { throw new InvalidOperationException(); }
}
</pre>

]]></description>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2123</key>
    <type>BUG</type>
    <name>Values should not be uselessly incremented</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public int PickNumber()
{
  int i = 0;
  int j = 0;

  i = i++; // Noncompliant; i is still zero

  return j++; // Noncompliant; 0 returned
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public int PickNumber()
{
  int i = 0;
  int j = 0;

  i++;
  return ++j;
}
</pre>

]]></description>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3898</key>
    <type>CODE_SMELL</type>
    <name>Value types should implement "IEquatable&lt;T&gt;"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>If you're using a <code>struct</code>, it is likely because you're interested in performance. But by failing to implement
<code>IEquatable&lt;T&gt;</code> you're loosing performance when comparisons are made because without <code>IEquatable&lt;T&gt;</code>, boxing and
reflection are used to make comparisons. </p>
<h2>Noncompliant Code Example</h2>
<pre>
struct MyStruct  // Noncompliant
{
  private int i;
  public int I
  {
    //...
  }
}
</pre>

]]></description>
    <tag>performance</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1117</key>
    <type>CODE_SMELL</type>
    <name>Local variables should not shadow class fields</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Shadowing fields with a local variable is a bad practice that reduces code readability: it makes it confusing to know whether the field or the
variable is being used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Foo
{
  public int myField;

  public void DoSomething()
  {
    int myField = 0;  // Noncompliant
    ...
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/2ADEAw">CERT, DCL51-J.</a> - Do not shadow or obscure identifiers in subscopes </li>
</ul>

]]></description>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S1481</key>
    <type>CODE_SMELL</type>
    <name>Unused local variables should be removed</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will
not wonder what the variable is used for.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public int NumberOfMinutes(int hours)
{
  int seconds = 0;   // seconds is never used
  return hours * 60;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public int NumberOfMinutes(int hours)
{
  return hours * 60;
}
</pre>
<h2>Exceptions</h2>
<p>Unused locally created resources in a <code>using</code> statement are not reported.</p>
<pre>
using(var t = new TestTimer()) // t never used, but compliant.
{
  //...
}
</pre>

]]></description>
    <tag>unused</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S2290</key>
    <type>CODE_SMELL</type>
    <name>Field-like events should not be virtual</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>Field-like events are events that do not have explicit <code>add</code> and <code>remove</code> methods. The compiler generates a
<code>private</code> <code>delegate</code> field to back the event, as well as generating the implicit <code>add</code> and <code>remove</code>
methods.</p>
<p>When a <code>virtual</code> field-like <code>event</code> is overridden by another field-like <code>event</code>, the behavior of the C# compiler
is to generate a new <code>private</code> <code>delegate</code> field in the derived class, separate from the parent's field. This results in multiple
and separate events being created, which is rarely what's actually intended.</p>
<p>To prevent this, remove the <code>virtual</code> designation from the parent class event.</p>
<h2>Noncompliant Code Example</h2>
<pre>
abstract class Car
{
  public virtual event EventHandler OnRefueled; // Noncompliant

  public void Refuel()
  {
    // This OnRefueld will always be null
     if (OnRefueled != null)
     {
       OnRefueled(this, null);
     }
  }
}

class R2 : Car
{
  public override event EventHandler OnRefueled;
}

class Program
{
  static void Main(string[] args)
  {
    var r2 = new R2();
    r2.OnRefueled += new EventHandler((o, a) =&gt;
    {
      Console.WriteLine("This event will never be called");
    });
    r2.Refuel();
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
abstract class Car
{
  public event EventHandler OnRefueled; // Compliant

  public void Refuel()
  {
    if (OnRefueled != null)
    {
      OnRefueled(this, null);
    }
  }
}

class R2 : Car {}

class Program
{
  static void Main(string[] args)
  {
    var r2 = new R2();
    r2.OnRefueled += new EventHandler((o, a) =&gt;
    {
      Console.WriteLine("This event will be called");
    });
    r2.Refuel();
  }
}
</pre>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3597</key>
    <type>CODE_SMELL</type>
    <name>"ServiceContract" and "OperationContract" attributes should be used together</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The <code>ServiceContract</code> attribute specifies that a class or interface defines the communication contract of a Windows Communication
Foundation (WCF) service. The service operations of this class or interface are defined by <code>OperationContract</code> attributes added to methods.
It doesn't make sense to define a contract without any service operations; thus, in a <code>ServiceContract</code> class or interface at least one
method should be annotated with <code>OperationContract</code>. Similarly, WCF only serves <code>OperationContract</code> methods that are defined
inside <code>ServiceContract</code> classes or interfaces; thus, this rule also checks that <code>ServiceContract</code> is added to the containing
type of <code>OperationContract</code> methods.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[ServiceContract]
interface IMyService // Noncompliant
{
  int MyServiceMethod();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
[ServiceContract]
interface IMyService
{
  [OperationContract]
  int MyServiceMethod();
}
</pre>

]]></description>
    <tag>api-design</tag>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>2min</remediationFunctionBaseEffort>
  </rule>
  <rule>
    <key>S3598</key>
    <type>BUG</type>
    <name>One-way "OperationContract" methods should have "void" return type</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>When declaring a Windows Communication Foundation (WCF) <code>OperationContract</code> method one-way, that service method won't return any result,
not even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return
type therefore does not make sense.</p>
<h2>Noncompliant Code Example</h2>
<pre>
[ServiceContract]
interface IMyService
{
  [OperationContract(IsOneWay = true)]
  int SomethingHappened(int parameter); // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
[ServiceContract]
interface IMyService
{
  [OperationContract(IsOneWay = true)]
  void SomethingHappened(int parameter);
}
</pre>
<h2>Exceptions</h2>
<p>The rule doens't report if <code>OperationContractAttribute.AsyncPattern</code> is set to <code>true</code>.</p>

]]></description>
    <remediationFunction>CONSTANT_ISSUE</remediationFunction>
    <remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
  </rule>
</rules>