
Formatted SQL queries can be difficult to maintain, debug and can increase the risk of SQL injection when concatenating untrusted values into the query. However, this rule doesn't detect SQL injections (unlike rule s3649), the goal is only to highlight complex/formatted queries.

## Ask Yourself Whether

- Some parts of the query come from untrusted values (like user inputs).
- The query is repeated/duplicated in other parts of the code.
- The application must support different types of relational databases.


There is a risk if you answered yes to any of those questions.

## Recommended Secure Coding Practices

- Use [parameterized queries, prepared statements, or stored
  procedures](https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet) and bind variables to SQL query parameters.
- Consider using ORM frameworks if there is a need to have an abstract layer to access data.


## Sensitive Code Example


    public void Foo(DbContext context, string query, string param)
    {
        string sensitiveQuery = string.Concat(query, param);
        context.Database.ExecuteSqlCommand(sensitiveQuery); // Sensitive
        context.Query<User>().FromSql(sensitiveQuery); // Sensitive
    
        context.Database.ExecuteSqlCommand($"SELECT * FROM mytable WHERE mycol={value}", param); // Sensitive, the FormattableString is evaluated and converted to RawSqlString
        string query = $"SELECT * FROM mytable WHERE mycol={param}";
        context.Database.ExecuteSqlCommand(query); // Sensitive, the FormattableString has already been evaluated, it won't be converted to a parametrized query.
    }
    
    public void Bar(SqlConnection connection, string param)
    {
        SqlCommand command;
        string sensitiveQuery = string.Format("INSERT INTO Users (name) VALUES (\"{0}\")", param);
        command = new SqlCommand(sensitiveQuery); // Sensitive
    
        command.CommandText = sensitiveQuery; // Sensitive
    
        SqlDataAdapter adapter;
        adapter = new SqlDataAdapter(sensitiveQuery, connection); // Sensitive
    }


## Compliant Solution


    public void Foo(DbContext context, string query, string param)
    {
        context.Database.ExecuteSqlCommand("SELECT * FROM mytable WHERE mycol=@p0", param); // Compliant, it's a parametrized safe query
    }


## See

- [OWASP Top 10 2017 Category A1](https://www.owasp.org/index.php/Top_10-2017_A1-Injection) - Injection
- [MITRE, CWE-89](https://cwe.mitre.org/data/definitions/89) - Improper Neutralization of Special Elements used in an SQL Command
- [MITRE, CWE-564](https://cwe.mitre.org/data/definitions/564.html) - SQL Injection: Hibernate
- [MITRE, CWE-20](https://cwe.mitre.org/data/definitions/20.html) - Improper Input Validation
- [MITRE, CWE-943](https://cwe.mitre.org/data/definitions/943.html) - Improper Neutralization of Special Elements in Data Query Logic
- [CERT, IDS00-J.](https://wiki.sei.cmu.edu/confluence/x/ITdGBQ) - Prevent SQL injection
- [SANS Top 25](https://www.sans.org/top25-software-errors/#cat1) - Insecure Interaction Between Components
- Derived from FindSecBugs rules [Potential SQL/JPQL Injection
  (JPA)](https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JPA), [Potential SQL/JDOQL Injection (JDO)](https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JDO), [Potential SQL/HQL Injection (Hibernate)](https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_HIBERNATE)

